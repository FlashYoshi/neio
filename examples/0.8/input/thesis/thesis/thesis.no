[Thesis]
{
    preface.createDocument((Document) parent());
    permission.createDocument((Document) parent());
    overview.createDocument(parent().addContent(new Abstract()));
    addContent(new Pdf('''ExtendedAbstract'''));
    addBibtex('''references''');
    Text lat = new LaTeX();
    String md = '''Markdown''';
    String pan = '''Pandoc''';
    mainMatter();
}

# Introduction
{Chapter intro = (Chapter) parent()}
In this thesis we introduce a new markup language that improves upon a few others, namely {lat} and {md}, whilst still holding on to their advantages.

The language has been used to write this entire book with the exclusion of the title page (which is auto-generated) and a few images.
The source code of the book is available on the {href("UGent GitHub", '''https://github.ugent.be/tivervac/neio/blob/master/examples/0.8/input/thesis/thesis/thesis.no''')} {cite('''neiosrc''')}.
In the same repository you also find the {href("Neio library", '''https://github.ugent.be/tivervac/neio/tree/master/examples/0.8/lib/neio''')} {cite('''neiolib''')} and source code for 
the {href("Neio compiler", '''https://github.ugent.be/tivervac/neio/tree/master/neio''')} {cite('''neiocompiler''')}.

Before we get into the details of this new language it is necessary to introduce some of the most used markup languages and word processors.

## State-of-the-art
Before we discuss the state-of-the-art, we first discuss the difference between saving a document in a human-readable or a binary format.

{md}, {lat} and {pan} use a human-readable format that can be opened in any editor, is quite robust to file corruptions and is well suited for Version Control Systems (VCS) such as Git and Mercury.
It is robust in the sense that a if a single bit of the document gets flipped, the document can still be repaired by the user.
The user can find the error on his own, or he can use the variety of editors to find help him as every editor can handle errors differently.

When the syntax gets more extensive and less human-readable, the chances to encounter a problem upon compilation increase.
This is both good and bad, if a part of the syntax got corrupted, the compiler tells you and you know that the document has been corrupted.
Had it not warned the user, the document would be in a corrupt state without the user noticing so.
On the other hand the corruption can prevent the document from successfully compiling, forcing the user to find out what happened to the document.
In any case however, the error can still be tracked down and repaired.

This is not always possible, when using a binary format, like the ones used by default in What You See Is What You Get (WYSIWYG) editors for example.
As a matter of fact, we created a Word document and flipped one bit in a random byte using a hex editor.
We then tried to open the document and received the following sequence of errors and were unable to retrieve the contents of the file.
{{
    image("The detection of an error.", '''wordCorruption''').scale(80);
    image("The warning before trying to repair the error.", '''wordCorruption2''');
    image("The inability to repair the error.", '''wordCorruption3''').scale(80);
}}

A regular user, without technical expertise, is not be able to repair this error as the source code is not human-readable.
There are also almost no other tools to help the user as the binary format can only be interpreted correctly by a few editors.

It is to be noted that the error handling depends on what exactly was corrupted, in some cases the corruption can be automatically repaired.

### Word processors
{Chapter goodWord = (Chapter) parent()}
The best-known solution for creating documents, are so called WYSIWYG editors, examples include \`Microsoft Word' and \`Pages'.
They are called as such because you immediately, without compiling, see what your final document is going to look like.
Because of this, the complexity of the tool is significantly decreased allowing anyone to use the tool.
It is less complex because you do not have to type in commands and wait for a preview to change.
Instead you select the property from a drop-down list or click a button and the document is updated instantly.
The GUI essentially hides the complexity.

A WYSIWYG editor gives the author freedom, for example it is very easy to change a font or change the font size of a certain part of the text
and you can easily add an image and drag-and-drop it around.

A lot of these editors are grouped into packets, such as Office or LibreOffice.
Using one of these packets, it is also easy to insert slides, tables or another document {cite('''ole''')}.
These are then be editable with the specialized program for it (like Excel), but you do not have to leave the document.
In the example below an Excel chart has been inserted into a Word document.
{
    image("An Excel chart in a Word document.", '''excelInWord''')
}

Collaboration is also made easy by using online versions of these solutions, such as \`Microsoft Word Online' or \`Google Docs'.
These make documents cross-platform and allow multiple people to work on them at the same time.
It is also possible to add comments or suggestions on (online) documents.
These changes can then be resolved in just one click by an authorized editor.

Some documents are however more complex and have need for a more powerful tool such as {lat}.

### {lat}
{Chapter latexAdv = (Chapter) parent()}
{lat} is a document preparation system that uses the TeX typesetting system.
It provides a set of extra macros that can be used on top of the TeX macros.

{lat} provides rich customisability through the Turing complete programming model provided by TeX.
The model is different from modern programming models, it does not use regular variables or functions, instead it uses macros.
A macro or command looks like the following: `\\cmdname\[opt-arg\]\{req-arg\}`.
Here `cmdname` is the name of the command, `opt-arg` are the optional arguments and `req-arg` are the required arguments.
To show how commands work, we show the process involved in processing some input that includes a command.

In {lat}, every character and command in the input is a token, `a` is a token but `\\command` is also a token.
The input is transformed into a list of tokens and is then processed token after token.
When a command is encountered, it is expanded.

Expansion removes the current token from the list and adds every expandable item in its body to the token list recursively.
This is best shown using an example.

We define two commands using `\\newcommand` and call the `\\y` command.
{
    new LstListing('''
\\newcommand{\x}{a command}
\\newcommand{\y}{This is \x}
\y''')
}

The output is `This is a command`.
The step-by-step expansion is given below:
- {lat} encounters the token `\\y` without arguments and expands it.
- `\\y` is removed from the token list and `This is \\x` is added to it.
- `This is` is read and `\\x` is encountered, `\\x` gets expanded.
- `\\x` is removed from the token list and `a command` is added.

We can also pass arguments to a command by specifying the amount of arguments as an optional argument.
We can then access the arguments by using the `hash` symbol followed by a number.
For example, the output of code beneath is: `This is an argument`.
{
    new LstListing('''
\\newcommand{\command}[1]{This is #1}
\command{an argument}
''')
}

The braces around the first required argument are optional, thus we can also write this as follows:
{
    new LstListing('''
\\newcommand\command[1]{This is #1}
''')
}

To elaborate further on expansion, we have a look at another example.
We have the string `Hello` saved in a command and want to concatenate a string to it so that it prints out `Hello world`.
To do this, we have to redefine the command, this can be done using `\\renewcommand`.
We thus get the following:
{
    new LstListing('''
\\newcommand\example{Hello}
\\renewcommand\example{\example{} world}
    ''')
}

The `\{\}` at the end of `\\example` is used as a delimiter, to know when the `\\example` command ends, such that the space behind it does not disappear.
This example does not work however as `\\example` is recursively calling the new definition instead of calling the old one once.
To counter this, `\\example` in the new definition should be expanded first, we can to that using `\\expandafter` as shown below.
{
    LstListing latExample = new LstListing('''
\\newcommand{\example}{Hello}
\expandafter\\renewcommand\expandafter\example\expandafter{\example{} world}
\example
''');
    return latExample;
}

`\\expandafter` removes the first two tokens behind itself from the token list, expands the second token and then adds the expanded token and the first token back to the token list.

The step-by-step expansion for the previous example is given below:
- `\\example` is defined for the first time.
- The second definition begins.
- `\\expandafter` removes `\\renewcommand` and `\\expandafter` and expands the latter.
- The second `\\expandafter` removes `\\example` and `\\expandafter` and expands the latter.
- The third `\\expandafter` removes `\{` and `\\example` and expands the latter to `Hello`.
- `\\renewcommand`, `\\example`, `\{` and `Hello` are placed back on the token list.
- The token list \(`\\renewcommand\example\{Hello world\}`\) is now expanded normally.

Using this programming model, libraries, called packages can be created.
Over the course of the past 31 years (the initial {lat} release was in 1985), a lot of them have been created.
They offer all kinds of functionalities, ranging from the creation of sheet music and slide shows {cite('''beamer''')} to providing the base to write letters and books.
This is one of the reasons why {lat} is often used for long and complex documents such as books, scientific papers and syllabi.

The goal of {lat} {cite('''latintro''')} is for the user to focus on the structure and content of the document and to let designers worry about the design of the document.
To make sure the document looks good afterwards, it is important to structure it using elements such as sections and paragraphs.
Because of the freedom given in WYSIWYG word processor, it is often forgotten to use styles, headers and so on.
This can cause inconsistencies to appear as the document grows.

Designers can use the very sophisticated typesetting of {lat} to create designs for well structured {lat} documents.
The typesetting improves readability by supporting kerning, ligatures,... and using the advanced Knuth-Plass line-breaking algorithm {cite('''texlba''')}.
The algorithm sees a paragraph as a whole instead of using a more naive approach and seeing each line individually.
Kerning places letters closer together or further away depending on character combinations.
A ligature is when multiple characters are joined into one glyph.
{{
    image("Kerning on", '''kerning''').scale(50).leftOf(new Image("Kerning off", '''nokerning''')).scale(55);
    image("Ligature on", '''ligature''').scale(50).leftOf(new Image("Ligature off", '''noligature''')).scale(55)
}}

{lat} also knows how to work with bibliographies by using programs such as Bib(La)TeX or Biber.
These are reference management programs that are very robust and make certain that all of your references are consistent.
They allow you to create the references outside of your main document, decreasing the amount of clutter in the document.

Whilst on the topic of including other files in your document, in {lat} you can split up your document into multiple smaller documents, allowing for easier management.
A common use of this function is to write every chapter, for example in a book, in a separate document and than all the chapters are imported into the main document.
This allows to easily remove or switch out different parts of a document. This is also possible in {pan} (as you can inline {lat}\) and the WYSIWYG editors {cite('''ole''')}.

Finally, {lat} employs a free and open source model, which is a big reason why it is so popular in the open source community.
As a result of this model, combined with its popularity and good scientific support, LaTeX has been integrated in many other applications.
A few examples are:
* MediaWiki {cite('''mwikilat''')} {cite('''mediawiki''')}: a free and open-source software package that powers sites as Wikipedia {cite('''wikipedia''')} and Wiktionary {cite('''wiktionary''')}.
* Stack Exchange {cite('''stackexchange''')}: a network of Q\&A web sites
* JMathTex {cite('''jmathtex''')}: a Java library adds functionality to display mathematical formulas in a Java application

{lat} is powerful but it is also complex and has a steep learning curve, because of this, simpler alternatives such as {md} have been created.

### {md}
The goal of {md} {cite('''markdown''')} is to be easy-to-write and read as a plain text document and as such is actually based on plain text emails.
Its appeal lies in its simplicity as it allows to for example easily create a simple document, such as a short report or a blog post.

It achieves this simplicity, by introducing a small and simple syntax {cite('''mdsyntax''')} that feels natural.
For example, to create a title you underline it with `minus` or `equals` characters.
To create an enumeration, you use `star` characters as bullet points.
An example {md} document is shown below:
{{
    Image i = image("The document rendered as HTML by the official {md} conversion tool.", '''document''').scale(40);
    i.rightOf(new LstInputListing('''document.md'''));
}}

This syntax decreases the amount of possible syntax errors and allows for short compile times and wide editor support.
It also allows {md} to be easily translated into other formats such as PDF or HTML.
As such, a tool to convert {md} to HTML is offered by the designers of the language itself.
This tool is also cross-platform and as such widens the target audience of {md}.

However, for a lot of cases {md} is too simple.
Because of this, solutions such as {pan} have been created.

### {pan}
{Chapter panAdv = (Chapter) parent()}
{pan} {cite('''pandoc''')} is a document converter, but it can do much more than just convert a document from one format to another.
Notably, it allows you to write inline {lat} in a {md} document, combining the power of both.
An example is shown below.
{{
    LstInputListing pandocListing = new LstInputListing('''pandocExample.md''');
    pandocListing.leftOf(image("The output of the document to the left.", '''pandocExample.png'''))
}}

However, outside of the {lat} one, {pan} does not really have a programming model and instead works with so called filters.
A document in {pan} can be read and transformed into an Abstract Syntax Tree (AST).
The AST is read in a filter, then transformed and passed on to the next filter.

Filters can be written in a multitude of languages such as Haskell, Python, Perl,... .
They are then passed as a command line argument to the conversion command.
We illustrate this using an example from the {pan} tutorial on scripting {cite('''panexample''')}.
{
    LstInputListing behead2 = new LstInputListing('''behead2.hs''');
    return behead2;
}

(Pandoc, 2016)

The example above shows a filter written in Haskell.
It replaces all the headers of level 2 or more in a {md} file by paragraphs with the text in italics (hence the `Emph` in the code).
The `toJSONfilter` function constructs a JSON representation of the AST.
Using this, we find the headers of level of 2 or more and create a new paragraph.
The document can be created using the following command `pandoc -f SOURCEFORMAT -t TARGETFORMAT --filter ./behead2.hs`.

This example shows the power of {pan}: it can do its work directly on the AST.
This means that the source document does not have to be a {md} document, it could also use HTML or any other supported input format.

Using another one of these filters, PanPipe {cite('''panpipe''')}, you can execute programs defined outside of a document.
The stdout of the program is inserted into the document and the stderr is redirected to the stderr of {pan}.
An example is shown below.
{
    LstListing panShell = new LstListing('''
This document executes a shell command.

```{pipe="sh"}
echo "Hello world! I am " $(whoami)
```
    ''')
}
{{
    panShell.leftOf(image("The output of the document to the left.", '''panShell'''))
}}

Using {pan}, you can also declare templates that allow you to use variables.
The value of the variables is predefined (such as `\$body\$`\) or passed in through the command line.
These can then also be used in conditionals or loops in this template.
You can see an example below.
{
    LstInputListing panLetter = new LstInputListing('''letterTemplate.latex''');
    return panLetter;
}
{{
    panLetter.leftOf(new LstInputListing('''letter.md'''))
}}

The document can then be build with the following command.
{
    new LstListing('''
pandoc letter.md -o letter.pdf --template letterTemplate --variable=addressee:"John Doe"
    ''')
}

## Problem statement
We can see that these solutions all have their advantages, but there are also quite a few disadvantages.
We discuss the most common ones for every solution underneath and afterwards we introduce the problem statement.

### Word processors
The UI in WYSIWYG editors allows you to customise the document, you can insert other documents, tables, figures,... and adjust a lot of properties.
It is also possible to use macros using for example Visual Basic for Applications in Word to automate some tasks.
It can for example be used to remove leading tab characters from paragraphs.

However, it has trouble with inserting variables.
Because of this, it is very cumbersome to compute a simple expression like `x + y`.
To do this, you first have to open the Visual Basic Editor.
In there you create a new module in which you define your new variables as follows.
{
    new LstListing('''
    ActiveDocument.Variables.Add Name:="x", Value:=27
    ActiveDocument.Variables.Add Name:="y", Value:=2
    ActiveDocument.Variables.Add Name:="result", Value:=(Int(ActiveDocument.Variables("x")) + Int(ActiveDocument.Variables("y")))
    ''')
}

The result variable can then be inserted by selecting `Quick parts` in the `Insert` tab, selecting `Field`, then selecting `DocVariable` and finally typing in `result`.
This inserts the `result` variable into the document, but the variable is not automatically update.
To achieve that you have to right-click it and click `Update field`.

In word processors small changes can also have big side effects on the document.
For example, you placed an image exactly where you wanted and later on, you add a newline somewhere higher up.
The reflowing of the text underneath it shifts the precisely placed image out of place.
These changes are not always immediately clear, which creates inconsistencies in the document.

Another problem that occurs with images (thought it is not an inherent problem of WYSIWYG editors, rather a bad implementation), 
is that the caption does not move together with the image.
In the example below an image is inserted and a caption is (by right-clicking the image and pressing `Add caption`\) added.
The image is then dragged to the end of the file and we see that the caption remains in place.
{
    Image wordCaption = image("Caption below the image.", '''wordCaption''');
    return wordCaption;
}
{{
    wordCaption.leftOf(new Image("The image moved, but the caption did not.", '''wordCaption2'''))
}}

### {lat}
Even though {lat} offers customisability through the programming model of TeX, it is not perfect.
The programming model is hard to use and read, creating a steep learning curve.
It also makes {lat} seem complex, scaring away a lot of potential users.
A way to counter this complex look, is LyX {cite('''lyx''')}. This is a GUI around {lat} offering some of the most common WYSIWYG features, while still utilizing the strength of {lat}.
Even though the complexity can be hidden under a GUI, it is still there and error messages are as bad as they were before, as is discussed beneath.

Having a cumbersome programming model, TeX makes it easy to create syntax errors.
When these are made TeX shows an error message, but these are often unclear.
See the excerpt below for an example.
{{
LstListing a = appendContent(new LstListing('''
\documentclass{article}
\begin{document}
\begin{equation}
$a$
\end{equation}
\end{document}'''));
a.leftOf(new LstListing('''
line 4: Display math should end with $$.<to be read again>a $a
line 5: You can't use `\eqno' in math mode.\endequation ->\eqno\hbox {\@eqnnum }$$\@ignoretrue \end{equation}
line 6: Missing $ inserted.<inserted text>$ \end{equation}
'''));
}}
The message means that `\$` is not allowed inside of an equation, but that is not clear from the error message.

As mentioned in {latexAdv.ref()}, the macro model does not work as we are used to in imperative and functional languages, we have to think about the order of expansions.
Keeping up with these expansions is confusing and requires a lot of work.
For example, if you want to use higher-order programming in TeX, you have to make sure that the function that is passed is not expanded immediately.

Next to this, we also have to watch out for name clashes, because in TeX, and {lat}, most of the macro definitions end up in the root namespace.
The `newcommand` we saw in {latexAdv.ref()}, requires that the command has not been defined earlier, if it was, an error is thrown.
`renewcommand` requires that the command was defined earlier, it overwrites the previous command and it crashes if the command was not yet defined.
Lastly, `providecommand` acts as `newcommand` if the command was not yet defined and does nothing if it was already defined, leaving the old definition intact.
For example, we can not define a command called `name` using `newcommand` as this command already exists, we have to use `renewcommand` to this.
This should be used with care however, as every command that uses `name` now uses the newly defined `name`.

Lastly, {lat} does not use a static type system while this could provide us with information needed for refactoring and auto-completion based on the context.

### {md}
{md} is simple but pays a hefty price for it.
All of the syntax elements have been hard-coded into the language meaning there is no room for customisability.
The only way to customise {md} is by embedding inline HTML.
This allows to create a solid structured model but it still does not allow for very much customisability.
There is no programming model that can provide the customisability.

As an example, we use HTML to create a table, as these are not a part of default {md} (though there are variations that have syntax for them, like GitHub Flavored {md} {cite('''ghfmd''')}).
{{
    Image i = image("The table document rendered as HTML by the official {md} conversion tool.", '''htmltable''');
    i.rightOf(new LstListing('''
Below you can find an HTML table
<table border="1">
    <tr>
        <td>
            Element 1
        </td>
        <td>
            Element 2
         </td>
     </tr>
</table>
    '''));
}}

Adding HTML to {md} decreases readability and cleanliness of your document significantly, which goes against the goal of {md}.
Using it also introduces the need for a certain technical proficiency to read and edit the source document.
Finally, HTML reintroduces the possibility of syntax errors and thus slows down the document creation.

### {pan}
{pan} allows you to execute exterior programs through the PanPipe filter, but the only result is the stdout and stderr of the program.
These do not allow you to change the output afterwards because you have no more structure.
The structural elements such as sections and paragraphs have disappeared.
For example, you create a binary tree using a 3rd party application.
Then you want to insert a new value into this tree, which requires it to be rebalanced.
However this is impossible as you lost all of the structure of the tree, it is only represented as a string.
You thus have to redraw every instance of the tree instead of creating it once, programmatically transforming it and redisplaying the transformed tree.

To access the structure of the document, the AST can be used.
Transforming an AST afterwards however, does not allow for precise control either.
In {behead2.ref()} we saw how we could replace all of the headers of a level higher than 2, but changing it for only a few would require us to find them.
If we could have done this inline or if we could redefine the meaning of the `\#` symbol, the problem would be avoided.

Finally, the variables used in {pan} have some limitations.
They can not be defined inline, only through the command line and they can only be used in templates.
This means that you can not easily embed variables and execute simple expressions such as `x + y`.

## Proposed solution: Neio
{Chapter goals = (Chapter) parent()}
To counter the problems occurring in the state-of-the-art solutions whilst retaining their advantages, we created a new markup language called `Neio` (read as neo).
The name `Neio` was chosen because `neo` means new and we are developing a new language.
The spelling however, came from the Colemak keyboard layout {cite('''colemak''')}, the letters on the home row, beneath the right hand, spell `n-e-i-o`.

Based on these solutions, the following goals were created for the Neio markup language:
- It has to be user-friendly and easy to get started with the language;
- It has to use a modern programming paradigm;
- It has to be highly customisable.

The first goal is achieved by using a syntax like {md} for the documents.

To achieve the second goal we note that a document has a strong structure consisting of a lot of elements like chapters, sections, paragraphs and so on.
An object-oriented model, like the one in Java, is able to represent this structure well by using an object for each element and
inheritance allows us to easily specialize an element, for example change the numbering of an enumeration.
We also chose this model because it is well known and as seen in {latexAdv.ref()} and {panAdv.ref()}, working with macro expansions or filters is not ideal.

Because it offers a powerful programming model that we can translate to, we chose to translate to {lat}.
It has also been used successively for decades and has proven that it can deliver very clean looking documents.
Later on more back ends, such as HTML, could be implemented, but that is outside of scope of this thesis.

### Target group
Neio targets anyone that is currently using {md} but wants to customise their document further.
For example, using Neio you can create citations and references, which is not possible in {md}.

By offering a simpler syntax than used in {lat}, we target {lat} users.
Finally, we target developers by offering a well-known, modern programming model that is more conventional than the macro model in TeX.

# Design of the Neio markup language
{Chapter design = (Chapter) parent()}
In {intro.ref()} the state-of-the-art concerning document creation has been discussed and we concluded that improvements can be made.
In this chapter the Neio language is presented.
We explain how our decisions were reached and how they were affected by the state-of-the-art.

## Neio document
The typical files that a user writes are called Neio documents; they have to be as simple as possible.
These files use the `.no` extension.
Based on our state-of-the-art analysis, we chose a {md}-like syntax for Neio documents.

To illustrate some of the basic concepts we present an example Neio document.
{
    LstListing neioEx = new LstListing("A simple Neio document.", '''
// This is a Neio document
[Document]

/* Below we define a chapter
 * and a paragraph.
 */
# Chapter 1
This is the first paragraph.
''');
    Image neioExImage = neioEx.leftOf(image("The rendered form of the document to the left.", '''simpleDocument''').scale(20));
}

Even if you are not familiar with {md}, you can immediately tell what this document represents.
It creates a document, a chapter (through the `\#` symbol) and a paragraph, and it contains two comments.

A difference with {md}, but a resemblance with {lat}, is that every Neio document starts out with document class.
It tells us what kind of document we are building.
This is done to improve customisability and to support multiple kinds of documents.

In Neio there are two sets of syntax called text- and code mode.
{neioEx.ref()} is written in text mode, the code files in next section are written in code mode.

## Code files
Code files are very similar to class files in Java.
They also use the `.no` extension.

Code files are fully compatible with Java.
This means that any Java code can be called from within a code file. This is very important because the Java ecosystem is enormous, a lot bigger than the one of TeX, and we can make use of it all.

To introduce code files, we take a look at the `Paragraph` class that is used to represent the paragraph in {neioEx.ref()}.
{
    Ranges parRanges = new Ranges().add(1, 52).add(62, 84);
    new LstInputListing(parRanges, '''../../examples/0.8/lib/neio/stdlib/Paragraph.no''');
}

Except for some variations on the syntax, such as using `namespace` instead of `package`, and the lack of access level modifiers (which can be specified), this is valid Java code.
The absent access level modifiers are automatically set to `private` for members and `public` for methods.
They do not have to be written explicitly as the default value is usually what the developer wants and it makes the code file just a little clearer and more concise.

To keep code files simple and to maximize reusability (as well as making the parsing somewhat easier), some functionality from the Java language was dropped.
It is for example not possible to create anonymous classes as these are not reusable and do not provide any new functionality.
It is also not possible to create multiple classes in a single file.

As we see in the next section, code files are used to build a Neio document.

## Call chain
A problem with {md} is that the semantics for the syntax are hard-coded in the language, a `\#` always represents a chapter for example.
But if you are creating a slide show for example, you want `\#` to create a new slide instead of a chapter.
For this reason, text mode in Neio has no hard-coded semantics.

Instead, the semantics of the syntax are defined in code files.
For example, the `\#` in a `Document` is defined as follows:
{
    LstInputListing docChapter = new LstInputListing(30, 41, '''../../examples/0.8/lib/neio/stdlib/Document.no''');
    return docChapter;
}

Now we can see that a Neio document is actually a sequence of method calls.
This is referred to as the `call chain`.
An example of a document and its call chain is shown below.
{
    LstListing methodChain = new LstListing('''
[Document]

# Chapter 1
This is the first paragraph.
''');
    return methodChain;
}
{{
    new LstListing('''
new Document()
    .#("Chapter 1")
    .text("This is the first paragraph.");
    ''').rightOf(methodChain)
}}

Note that the call chain is not code that the user has to write, its just a representation of a Neio document.

The user is thus actually creating an object model.
The object model for the previous document is shown below.
The calls that create every object are shown on the edges.
{
    image("The object model of the previous document.", '''simpleDocOM''').scale(80)
}

This object model is separated as much as possible from the visualisation, which happens later on.
We say \`\`as much as possible'' because it is not completely separated.
For example, sometimes it is specified that two elements should be placed next to each other in the object model.

Every element that is visualised in the final document is a `Content`.
`Content` is the base class of Neio, it is like `Object` in Java.

To customise the semantics of the syntax in text mode, the Java syntax in code files has been modified to allow for special method identifiers.
These are discussed in the next section.

## Method modifications
{Chapter methodMods = (Chapter) parent()}
To write the Neio documents we have seen so far, the regular Java methods used in code files had to be modified slightly.
We also had to reserve two method names that are not reserved in Java.
The modifications and the reasons for the modifications are given below.

### Symbol methods
{Chapter symbolChap = (Chapter) parent()}
In {docChapter.ref()} we saw that the code file, used a hash symbol as a method name.
These methods are called `symbol methods`.
All the symbols that can be used as method names are `\#, \-, \*, \_, \$, \|, \=, \^, \``. // `


These methods have either no arguments or a `Text` argument.
This is done to keep the method calls invisible for the user as more or different arguments would have to passed explicitly.
The `Text` that is passed to the method is the text following the call in text mode.
An example of both, and the call chain, is shown below.
{
    LstListing symMethods = new LstListing('''
[Document]
# Chapter 1
#
    ''');
    return symMethods;
}
{{
    new LstListing('''
new Document()
    .#("Chapter 1")
    .#()
    ''').rightOf(symMethods)
}}

A symbol method can only be used at the beginning of a line or after another symbol method.
The latter is used to chain methods together. We discuss applications of this in Chapter 3.

Next to symbols, there are two method names that have been reserved.
The first of them is `text` and is explained in the next section.

### Text
{Chapter textChap = (Chapter) parent()}
Whenever text in a Neio document is encountered on its own, for example a paragraph but not the text behind a `\#` symbol,
the `text` method is called with the text as an argument.
`text` is a separate method to allow continuation of the call chain and because not every block of text is necessarily a paragraph.
It can for example be a quote.

We use `Text` instead of just a Java `String` because `Text` can be marked up.
How this can be done is explained in the next section.

### Surround methods
Like in {md}, we want to markup text by placing it between a pair of characters.
For example, putting text in bold by surrounding it with a pair of `star` characters.
With the features that we have seen so far this is not yet possible.

To achieve this surround methods were developed.
A surround method is a method that is annotated with the `surround` modifier.
When text in text mode is surrounded with a pair of symbols, then a surround method is called.
A few examples of such methods are given below.
{
    new LstInputListing(131, 159, '''../../examples/0.8/lib/neio/lang/Text.no''');
}

The text `This is \*bold\* text` is thus transformed into the following call chain `text("This is ").text(\*(new Text("bold"))).text(" text")`.
The `text` call, wrapping the `\*` call, is necessary because the `\*` method only creates a `BoldText`. It does not append it to the current text.
Throughout the text the surround method `\`` is used a lot, it shows the text in a monospaced font. // `


As said in {symbolChap.ref()}, the argument of symbol methods is a Text, this means we can use surround methods in a symbol method.
A more extensive example of surround methods is shown below.
{{
    LstInputListing l = new LstInputListing('''surroundEx.input''');
    image("The rendered version of the document to the left.", '''surroundEx''').rightOf(l);
}}

To not confuse surround methods with the symbol methods, the first and last characters inside a surround call can not be a space.
The text after a symbol method on the other hand, is always separated from the symbol by at least one space.

### Nested methods
Documents often have recursive elements such as sections or enumerations.
With what we have seen thus far, we would have to create a new method for every level of recursion.
For example, to create sections, subsections and subsubsections, we have to create the following methods: `\#, \#\#, \#\#\#`.

This is of course very cumbersome and even impossible if there is no limit on the recursion.
The behaviour of such recursive elements is also very similar.
Usually, only one property, such as the numbering and indentation in an enumeration, is affected by the level of recursion.
This is why nested methods were developed.

A method can be annotated with the `nested` modifier.
Such a method implicitly takes an extra argument, an `Integer` that reflects the depth of this recursive method.
The depth of this recursive method is the number of times the symbol has been used.
If we have a look at the `Chapter` class, we see that it defines a nested method `\#`.
{
    new LstInputListing(32, 55, '''../../examples/0.8/lib/neio/stdlib/Chapter.no''');
}

If we now call `chapter.\#\#("Chapter 1.1")` for example, it translates to the following call: `chapter.\#("Chapter 1.1", 2)`.

A nested method only matches with at least two symbols, the single symbol has to be defined separately.
The first reason for this is because the first level often requires some initialisation.
A second reason is given once context types have been discussed.
An example of such initialisation is shown below.
{
    new LstInputListing(21, 35, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''');
}

When a `\*` call is encountered for the first time, an `Itemize` has to be created
The following `\*` calls then simply add an `ItemizeItem` to it.

The last method name that was reserved is `newline`.
It is explained in the next section.

### Newlines
{Chapter newlines = (Chapter) parent()}
Users often use varying amount of newlines to express different structures.
For example, the following two examples do not have the same meaning.
{
    LstListing twoLists = new LstListing("Two lists", '''
* Item 1
* Item 2

* Item 3
''');
    return twoLists;
}
{
    LstListing oneList = new LstListing("One list", '''
* Item 1
* Item 2
* Item 3
''');
    LstListing dump = oneList.rightOf(twoLists)
}

In {twoLists.ref()} there are two lists while in {oneList.ref()} there is only one list.
The same is done to separate paragraphs.

Because of this, and to include as much information as possible in the call chain, even the newline character is a method.
The newline character is defined by the following W3C Extended Backus-Naur Form (EBNF) {cite('''ebnf''')}:
{
    new LstListing('''
newline ::= "\\r?\\n"
    ''')
}

An example of a document and its call chain including the newline method is shown below.
{
    LstListing newlineEx = new LstListing('''
[Document]
The first line
of the first paragraph.

The first line
of the second paragraph.
    ''');
    return newlineEx;
}
{{
    new LstListing('''
new Document()
    .newline()
    .text("The first line")
    .newline()
    .text("of the first paragraph.")
    .newline()
    .newline()
    .text("The first line")
    .newline()
    .text("of the second paragraph.")
''').rightOf(newlineEx)
}}

This example shows that we never explicitly create a paragraph, this is done depending on the context.
We explain the example step-by-step to understand how the document is build.

The first `newline()` is defined in `TextContainer`, the super class of `Document`, and creates an intermediate object that is an instance of `NLHandler`.
The code for this method is shown below.
{
    new LstInputListing(12, 19, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''')
}

`NLHandler` defines the `text` method (shown below), which creates a paragraph and adds it to the parent, in this case the `Document`.
{
    new LstInputListing(29, 48, '''../../examples/0.8/lib/neio/stdlib/NLHandler.no''')
}

The second `newline()` is defined in Paragraph. It creates a new `ParNLHandler` which also defines a `text` method.
This `text` method (shown below) however does not create a new `Paragraph` but appends to the existing one.
{
    new LstInputListing(26, 34, '''../../examples/0.8/lib/neio/stdlib/ParNLHandler.no''')
}

Next there are two `newline()` calls. As we saw the first one creates a new `ParNLHandler`, but `ParNLHandler` also defines a `newline` method (given below).
This method returns the `NLHandler` defined by the parent (in this case `Document`\) of the existing `Paragraph`.
{
    new LstInputListing(12, 20, '''../../examples/0.8/lib/neio/stdlib/ParNLHandler.no''')
}

The next `text()` is thus called on an instance of `NLHandler` and as said before, creates a new `Paragraph`.
The following `newline()` and `text()` append some `Text` to the new `Paragraph` using a `ParNLHandler`, as seen before.

By introducing these special method identifiers we actually extended fluent interfaces {cite('''fluent''')}.
Because of this, the user is actually programming without noticing it.

In Chapter 3 we see that we can for example create tables as the one below.
{
    LstListing tableEx = new LstListing("A table created using a DSL.", '''
|      Student club      | Rounds | Seconds/Round | Dist (km) | Speed km/h | 
----------------------------------------------------------------------------- 
| HILOK                  |  1030  |      42       |   298,70  |   24,89    | 
| VTK                    |  1028  |      42       |   298.12  |   24.84    | 
| VLK                    |   841  |      51       |   243.89  |   20.32    | 
| Wetenschappen and VLAK |   819  |      53       |   237,51  |   19.79    | 
| VGK                    |   810  |      53       |   234.90  |   19.58    | 
| Hermes and LILA        |   793  |      54       |   229.97  |   19.16    | 
| HK                     |   771  |      56       |   223.59  |   18.63    | 
| VRG                    |   764  |      57       |   221.56  |   18.46    | 
| VEK                    |   757  |      57       |   219.53  |   18.29    | 
| VPPK                   |   689  |      63       |   199.81  |   16.65    | 
| SK                     |   647  |      67       |   187.63  |   15.64    | 
| Zeus WPI               |   567  |      76       |   164.43  |   13.70    | 
| VBK                    |   344  |     126       |    99.76  |    8.31    | 
    ''');
    return tableEx;
}

|      Student club      | Rounds | Seconds/Round | Dist (km) | Speed km/h | 
---------------------------------------------------------------------------- 
| HILOK                  |  1030  |      42       |   298,70  |   24,89    | 
| VTK                    |  1028  |      42       |   298.12  |   24.84    | 
| VLK                    |   841  |      51       |   243.89  |   20.32    | 
| Wetenschappen and VLAK |   819  |      53       |   237,51  |   19.79    | 
| VGK                    |   810  |      53       |   234.90  |   19.58    | 
| Hermes and LILA        |   793  |      54       |   229.97  |   19.16    | 
| HK                     |   771  |      56       |   223.59  |   18.63    | 
| VRG                    |   764  |      57       |   221.56  |   18.46    | 
| VEK                    |   757  |      57       |   219.53  |   18.29    | 
| VPPK                   |   689  |      63       |   199.81  |   16.65    | 
| SK                     |   647  |      67       |   187.63  |   15.64    | 
| Zeus WPI               |   567  |      76       |   164.43  |   13.70    | 
| VBK                    |   344  |     126       |    99.76  |    8.31    | 


This table is not an image that was included, but is actually created as shown in {tableEx.ref()}.
We do not need to create a special reader or to add new syntax to implement this table.
Instead we create a Domain Specific Language (DSL) to build tables using the features we have shown so far.

To avoid clutter, the `newline` method is not shown in the further examples unless it is needed to understand the example.

## Context types
{Chapter ctxTypes = (Chapter) parent()}
Every method in the call chain returns an object on which the rest of call chain is called.
However, we do not want to define the same symbol methods for all of these objects, for example defining `\#` in a `Document`, a `Chapter`, a `Paragraph` and so on.
We also do not want to specify on what object every method in the call chain is called.
For this reason context types were developed.

A method call in text mode is not always called on the previously returned object.
It can be called also be called on an another object which was defined earlier.
Context types use the object model, that has been built so far, to find out which object roots the next method call.

We illustrate this using an example.
{
    LstListing ctx1 = new LstListing('''
[Document]
# Chapter 1
This is the first paragraph.
# Chapter 2
    ''');
    return ctx1;
}
{{
    new LstListing('''
new Document()
    .newline()
    .#("Chapter 1")
    .newline()
    .text("This is the first paragraph.")
    .newline()
    .#("Chapter 2")
    ''').rightOf(ctx1)
}}

As we saw before, `Document` creates a `NLHandler` through the `newline` method.
However, `NLHandler` does not have a `\#` method.
`\#` in this example is called on `Document` instead and creates a `Chapter`.

`Chapter` also creates a `NLHandler` when `newline` is called on it and as we saw `NLHandler` defines `text`, which creates a `Paragraph`.

`Paragraph` creates a `ParNLHandler` when `newline` is called on it, but `ParNLHandler` has no `\#` method.
The last `\#` is again called on `Document`.
The call chain can be represented as a tree.
This is shown below.
{{
    image("The tree representation of the call chain of the previous example.", '''ctxObjectDiagram''')
}}

A context type is created every time a new method call (in the call chain) returns.
It has a context and an actual type.
The latter is the type of the object that was returned by the new method call.
The former is the context type in which the type that defines the method of the method call was found.

If the previous context type defines the method of your method call, but the actual type does not, then we search for the method in the context.

To understand how context types find the object on which a method is called, we go over the previous example step-by-step .

When we encounter `new Document()`, the first context type, called `ct0`, is created.
There are no context types yet, so there is no context and the actual type is `Document`.
The context type is shown below.
{{
    image("The first context type: ct0.", '''ct0''').scale(100)
}}

When we now encounter `newline()` we have to do a `context lookup`.
This lookup recursively searches through previous context types for the object that roots the method call.

The context lookup starts by checking if the actual type of the previous context type, `ct0`, defines a method `newline`.
As it does, we do not have to check the context of `ct0`.

The context of the new context type, `ct1`, is `ct0` and because `newline()` creates a `NLHandler` the actual type is `NLHandler`.
The tree representation of the call chain, with context types, now looks as follows.
{{
    image("The context types ct0 and ct1.", '''ct1''').scale(100)
}}

The next call is `\#("Chapter 1")` and the previous context type is `ct1`.
To know on what to call `\#` we first check if the actual type of `ct1` defines a `\#` method.
It does not, thus we check if the context of `ct1` does so instead.

The context of `ct1` is `ct0`, thus we first check if the actual type of `ct0` defines `\#`.
The actual type is `Document` and this defines `\#`.
The new context type, `ct2`, is thus created with `ct0` as context.
Because the `\#` in `Document` returns a `Chapter`, the actual type is `Chapter`.
The tree representation is shown below.
{{
    image("The context types ct0 through ct2.", '''ct2''').scale(100)
}}

The following call is `newline()`, we check the actual type of `ct2`, `Chapter`, and we know that it defines `newline`.
We thus create `ct3` with `ct2` as context and `NLHandler` as actual type.
`ct4` and `ct5` are created with respectively `ct3` and `ct4` as context and respectively `Paragraph` and `ParNLHandler` as actual type.
The tree representation of `ct0` through `ct5` is shown below.
{{
    image("The context types ct0 through ct5.", '''ct5''')
}}

Finally, `\#("Chapter 2")` is called.
For this call we recursively search back up to `ct0` as it is the first context type in which `\#` is defined.
`(Par)NLHandler, Paragraph` and `Chapter` have no definition of `\#`, only `Document` has such a definition.
The last context type is thus built with ct0 as context and `Chapter` as a actual type.
The final tree representation is shown below.
{{
    image("The context types ct0 through ct6.", '''ct6''')
}}

It is important to note that we do not carry the entire context along for the entire document.
In the last step of the previous example, a `context reset` happened as part of the lookup procedure.
After a context reset a part of the object model becomes inaccessible for future method calls in the call chain.
This is needed to correctly create the object model.

To show why context resets are important we give another example:
{
    LstListing ctxEx2 = new LstListing("An example for context resets.", '''
[Document]
* Item 1
* Item 2

Paragraph 1
* Item 3
    ''');
    return ctxEx2;
}
{{
    new LstListing('''
new Document()
    .*("Item 1")
    .*("Item 2")
    .newline()
    .text("Paragraph 1")
    .*("Item 3")
    ''').rightOf(ctxEx2)
}}

The example has the following object model.
The methods that cause a context reset have been coloured red.
{
    image("The object model of the previous example.", '''ctxEx2OM''').scale(70)
}

The `\*` is defined in `Document` and creates `Itemize i1`.
The `\*` defined in `Itemize` creates `ItemizeItem`s and adds them to the `Itemize`.
Because of context resets, the last `\*` is called on `Document`.
This document thus contains an itemize of two items, a paragraph and an itemize of one item.
The correct context lookup for the last `\*` is visualised on the call chain below, the arrows depict one step in the context lookup.
{
    image("Correct context lookup for \*.", '''timeline1''')
}

If there were no context resets and the entire context was thus kept in every step, `Item 3` would find the `\*` defined in `Item 2` before it reached `Document`.
This means that there would only be one list, that contains all three items, instead of two lists as was meant in the document.
This wrong context lookup for the last `\*` is visualised on the call chain below.
{
    image("Wrong context lookup for \*.", '''timeline2''')
}

Finally, context types are only used for text mode, or when `this` is used in code mode.
This is because we want code mode to do exactly what the user instructed it to.
If we incorporate context types in the code mode, then the meaning of the code can change by making changes to the text above it.

#### Nested methods
Now that we know how context types work, we can explain why the first level of a nested method is separated from the rest.
We explain why this is needed using the following example:
{
    LstListing singleNested = new LstListing('''
[Document]
# Chapter 1
## Chapter 1.1
# Chapter 2
    ''');
    return singleNested;
}
{
    LstListing nestedTrans = new LstListing('''
new Document()
    .#("Chapter 1")
    .#("Chapter 1.1", 2)
    .#("Chapter 2")
    ''').rightOf(singleNested);
}

We want `Chapter 1` and `Chapter 2` to be children of `Document` and `Chapter 1.1` should be a child of `Chapter 1`.
The context type representation of the document is shown below.
{{
    image("The correct context type representation.", '''NestedCorrect''');
}}

If we did not separate the first level, the aforementioned structure is still built correctly, *but* the ContextType representation is different.
This is because we did not reset to the same point, the context reset jumped up to `Chapter 1` instead of `Document`.
The context type representation of this document is shown below.
{
    Image nestedWrong = image("The wrong context type representation.", '''NestedWrong''');
}

## Code blocks
{Chapter codeBlocks = (Chapter) parent()}
We have seen that we can use code in code files and customise our document this way.
But this does not allow us to do everything we want to.
We want to define variables and execute short expressions such as `x + y`
We do not want to create a new document class every time we want to do something out of the ordinary.

We want to change properties of content in a Neio document without touching code files.
It also has to be possible to insert content in such a document without using a symbol method.
For example, we can create a class for pie charts but as there is no symbol method that creates it in the existing document classes,
we can not insert it with the features discussed thus far.

For this reason, it is possible to add code blocks in a Neio document.
The three different kinds of code blocks are explained below.

### Non-scoped code
{Chapter nsCode = (Chapter) parent()}
The first kind of code blocks is the non-scoped code block.
We show how it is used with an example.
{
    LstListing nsCodeEx = new LstListing('''
[Document]
# Chapter 1
{
    Chapter chapter2 = new Chapter("Chapter 2")
}
    ''');
    return nsCodeEx;
}
{{
    new LstListing('''
new Document()
    .#("Chapter 1");
Chapter chapter2 = new Chapter("Chapter 2");
    ''').rightOf(nsCodeEx)
}}

In the example above a code block is opened and a new `Chapter` is created.
A non-scoped code block is defined by the following EBNF:
{
    new LstListing('''
nl ::= "\\r?\\n"
non-scopedCodeBlock ::= "{" nl (statement ";" nl*)* nl* statement nl* ";"? nl* "}" "nl"
    ''')
}

The statements in such a block are injected directly into the document, without introducing a scope.
This means that we can use variables defined in a non-scoped block, later on in the document.
However, this means that we should be careful when choosing names for our variables as they are added to the global
namespace of the Neio document.

We have now created a `Chapter`  but it is not part of the document yet.
We could add it manually by calling `addContent()`, but there is an easier way as this is a pattern that occurs a lot.

If the last statement in a non-scoped code block returns an object, this object is appended to the current document.
We can thus also use a return statement as last statement to add an object to the document.
These two possibilities are shown below.
{
    LstListing nsCodeEx2 = new LstListing("Automatic return from code block.", '''
[Document]
# Chapter 1
{
    new Chapter("Chapter 2")
}
    ''');
    return nsCodeEx2;
}
{{
    new LstListing("Manual return from code block.", '''
[Document]
# Chapter 1
{
    Chapter chapter2 = new Chapter("Chapter 2");
    return chapter2;
}
    ''').rightOf(nsCodeEx2)
}}

The object returned in the last statement is added to the document and it becomes part of the context.
It is added to the document by calling `appendContent` on `this`.
To further explain code blocks we explain `this` in the next section.

### This
{Chapter thisCode = (Chapter) parent()}
Like every object-oriented language, Neio has an expression to refer to the current object.
Because the document is actually a chain of method calls, it is set to the last object returned before a code block.
When an object is returned from a code block and added to the document, this object becomes the new `this`.

We need `this` as we do not know how to refer to the objects that were created in text mode.
The example in {nsCodeEx2.ref()} can be seen as the following call chain.
{
    new LstListing('''
new Document()
    .#("Chapter 1");
Chapter chapter 2 = new Chapter("Chapter 2")
this.appendContent(chapter 2);
    ''')
}

A separate statement is created for the call chain before a code block.
The object returned from the code block is placed in a variable and passed to the `appendContent` method call.
When {nsCodeEx2.ref()} is actually translated, `this` is be filled in and it produces the following code:
{
    new LstListing('''
Document $var0 = new Document();
Chapter $var1 = $var0.#("Chapter 1");
Chapter $var2 = new Chapter("Chapter 2");
$var1.appendContent($var2);
    ''')
}

`this` is filled in with the last object that was returned in the call chain before the code block.
To do this the compiler has knowledge of the `appendContent` method.

We show another example to show how context types and `this` work together.
For this example we use the following document:
{
    LstListing nsCodeEx3 = new LstListing('''
[Document]
# Chapter 1
{
    Chapter chapter2 = #("Chapter 2")
}
    ''');
    return nsCodeEx3;
}
{{
    new LstListing('''
new Document()
    .#("Chapter 1");
Chapter chapter2 = this.#("Chapter 2");
    ''').rightOf(nsCodeEx3)
}}

In this example we create a chapter as we do in text mode, by using the `\#` method.
`Chapter` has no `\#` method, but has `Document` does.
The method already adds the created `Chapter` to the `Document`.
Thus we assign a value to the result of the `\#` method to prevent it from being automatically appended like it was in the previous examples.

Because of context types `this` is be filled in by the variable that holds `Document` instead of the last object that was returned in text mode.
The final translation is given below.
{
    new LstListing('''
Document $var0 = new Document();
Chapter $var1 = $var0.#("Chapter 1");
Chapter chapter2 = $var0.#("Chapter 2");
    ''')
}

### Scoped code
Sometimes all we want to do is execute some arbitrary code without corrupting the namespace.
For this, we use a scoped code block.
Its use is illustrated below.
{
    new LstListing('''
[Document]
# Chapter 1
{{
List<String> l = new ArrayList<String>();
l.add("upquote");
l.add("pdfpages");
l.add("url");
for (int i = 0; i < l.size(); i = i + 1) {
    addPackage(l.get(i));
}
}}
    ''');
}

In this example a `Document` is created, but to suit our needs, it needs a few more packages that are not included by default in `Document`.
We also do not want to think of very descriptive identifiers for our variables as it is just a simple operation, the name `l` should suffice.

A scoped block does the same as a non-scoped code block but it injects all of the code in a new scope.
The last statement is not automatically appended to the document, to be certain that nothing leaves the scope.
A scoped block can thus be used as a safe way to execute code without adding anything to the document, changing the current `this` or polluting the global namespace.

The call chain of this example is given below.
{
    new LstListing('''
new Document()
    .#("Chapter 1");
{
    List<String> l = new ArrayList<String>();
    l.add("upquote");
    l.add("pdfpages");
    l.add("pdfpages");
    for (int i = 0; i < l.size(); i = i + 1) {
        this.addPackage(l.get(i));
    }
}
    ''');
}

Scoped blocks have been used frequently while creating this document.
One of its prominent uses has been to add images.
This is because `TextContainer` defines an `image` method that already adds the image to the document.
As we do not want to add the object twice, we use scoped code blocks to call this method.
The image method and and example of how images are typically included is shown below.
{
    LstListing scopedCodeEx = new LstListing('''
[Document]

{{
    image("image1")
}}
    ''');
}
{{
    new LstInputListing(53, 75, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''').leftOf(scopedCodeEx)
}}

### Inline code
{Chapter inlineCodeChap = (Chapter) parent()}
The the last type of code blocks are inline code blocks.
As the name implies, this is code that is meant to be used inline.
As such it can only contain one statement and the opening and closing bracket have to be on the same line.

Inline code blocks can be used anywhere that text can be used.
In the example below we show how inline code blocks can be used in combination with a non-scoped code blocks to create a template for a letter.
{{
    image("The rendered form of the example to the left.", '''inlineCode''')
    .rightOf(new LstInputListing('''../../examples/0.8/input/variablesInput/template/template.no'''))
}}

An inline code block returns a text and is appended to the rest of the document by calling the `text` method on `this`.

## Text in code mode
In the previous sections we created objects such as `Chapter`s as follows `new Chapter("Chapter 1")`.
However, `"Chapter 1"` is not a Java `String` it is a `Text`.
`Text` can thus be written in code mode by enclosing text with a pair of doubles quotes \(`\"`\).

A Java `String` is can still needed and can therefore be created using a pair of triple, single-quotes \(`\'\'\'`\).
One of the most prominent reason for using `String` instead of `Text` is when you have to pass a path for example to pass code to a code listings.

The inspiration for using three quotes came from the multi-line String literal in Python.
The reason we use three single quotes, instead of only, is because a pair of single quotes still represents a Java `Character`.
We do not use two quotes because that that would be very confusing when used in combination with double quotes in a non-monospace font.

As we saw in {inlineCodeChap.ref()}, you can use code blocks in text mode.
Since we can also use text mode in code mode, this means we can endlessly nest text and code mode.

An example demonstrating the strength of this nesting is shown below.
{{
    image("The rendered form of the example to the left.", '''dice''')
    .rightOf(new LstInputListing('''../../examples/0.8/input/variablesInput/dice/dice.no'''))
}}

In this example we play a game where we roll two dice.
In case we roll more than half of the total possible amount (12 in this case), we win.

In every case of the if statement, a piece of `Text` is found.
As we saw in {textChap.ref()}, this is translated to a `text` call.
Since we placed and empty newline before the code block, this `text` is called on a `NLHandler` and a new paragraph containing the results of the game is created.

## Navigating through the lexical structure
We have discussed all the features of Neio and we know how the object models are build.
The lexical structure represented by the object model can now be navigated using a few methods in `Content`.

For example, we can use the `nearestAncestor` and `directDescendants` methods to count the number of top-level chapters in a document.
An example of this is shown below as well as the code for the two methods.
{{
    LstListing lexEx = new LstListing('''
[Document]
# Chapter 1 
## Chapter 2
# Chapter 2

This document contains {nearestAncestor(Document.class).directDescendants(Chapter.class).size()} top-level chapters.
    ''');
    image("The rendered version of the example to the left.", '''lexEx''').rightOf(lexEx)
}}

{
    Ranges lexRanges = new Ranges().add(258, 271).add(317, 334);
    new LstInputListing(lexRanges, '''../../examples/0.8/lib/neio/lang/Content.no''')
}

## Considerations
{Chapter considerations = (Chapter) parent()}
Whilst constructing Neio, a few other things were considered but not implemented. They are discussed below.

## Customisation
We want to easily customise simple properties of the content.
For example, we want to easily say that we want to create a new chapter with a different font colour.
The only way to do so at this time is by opening a code block and calling methods on the content we want to change.

It might be better to provide some kind of syntax for this.
That way we can provide customisation in the same line as the content definition.
In {lat} for example, this is done by passing optional arguments as key-value pairs to the macro.

### Static typing
Neio has been designed to use static typing.
The reason for this is, that while we are writing a Neio document in Code mode, or we are writing a Neio class, we can be notified of possible type mismatches.
This decreases the time spent debugging and spent waiting on the compiler as you weed out one type mismatch after another.

It also allows you to create a safer program, as type errors are caught at compile time.
On the other hand when using dynamic typing, type errors only show up at runtime.
Using auto-completion in an IDE, we also do not have that much more typing to do than when we would be using dynamic typing.

The types have been incorporated into the Neio compiler, but the necessary checks to create comprehensive error messages are not yet in place.
In the current compiler, a `LookupException` is thrown whenever there is a type mismatch, undefined variable,... as the method or variable that we are looking for can not be found.

### Security
Another issue that we have considered is security.
This is an issue because it is possible to directly execute Java code from the Neio document.
However, security is also an issue in {lat}, as has been shown in several articles {cite('''checkoway2010text''')} {cite('''checkoway2011don''')}.

Since Neio is more readable than {lat}, malicious code can be found more easily than in {lat}.

Adding a layer of security on top of Neio would require a lot of effort and research and is not in scope of this thesis.
Thus we conclude by saying that we known there is a security risk, but dismissing it is seen as future work.

# Supported document types and libraries
{Chapter examples = (Chapter) parent()}
This chapter goes into more detail about what document types can be handled by Neio and how to specifically build these kind of documents.
We also show the flexibility of Neio by discussing some libraries that have been developed.

## Document classes
Before we discuss the developed document classes it is important to note that there is still a lot more work has to be done on them.
If we just have a look Memoir {cite('''memoir''')} or KOMA-Script {cite('''komascript''')}, we see that they consist of 609 and 419 pages respectively.
This is not something we could hope to reproduce in the scope of this thesis.
Memoir introduces a new document class that integrates some often used design-related packages with the book class.
KOMA-Script is a bundle of several classes and packages.


### Document class definition
The document class to be used in a Neio document is defined by placing `\[DocumentClass\]` at the top of the file.
With this line you are specifying what the first object in a Neio document has to be.
This object is the root of the call chain.

However, a document class definition is actually an expression that returns an object of this type.
For example, when you write `\[Document\]`,
what you get as root of the call chain might be a `Document`.
It might also be an instance of the `Thesis` document class, discussed in the next section, as `Thesis` is a subclass of `Document`.

The reason that this could be also be a subclass is because documents can also be included in another document.
To include a document we can pass the main document to the included document.
The included document then uses the main document as root of its call chain.

Because of this it is good practice to choose the most generic document class that is available for your document.

### Document
The simplest of documents can be created using the `Document` document class.
It provides the syntax to create anything that {md} can create, and on top of that it allows you to create tables, {lat} math, UML diagrams,... .

Like every Neio document, it can also use the code blocks defined in { codeBlocks.ref() } to customise your document.
For example, it is possible to place two `Content`s next to each other by using the `leftOf` and `rightOf` methods that are defined in the `Content` class.
The code of these methods is shown below.
{
    new LstInputListing(117, 185, '''../../examples/0.8/lib/neio/lang/Content.no''')
}

This code takes the parent of one of the two `Content`s, the base, and links the other Content to the base.
The implementation creates a root {lat} `Minipage` {cite('''minipage''')} if none of these objects is already next to another object.
Otherwise it just wraps the two `Content`s in a `Minipage`.
The root `Minipage` takes up the total width, while the `Minipage`s that wrap the content take up (1/children) of the width.

Another way of implementing this, that would probably have worked better, was through `TikZ` pictures.
It would have been better because it allows you to easily set any two things next to or above/beneath each other.
`Minipage`s require a lot more manual work and they might also split at a page-end which is not what wanted.

The `Document` document class can thus be used to write simple documents, such as small reports.
Another document class that is complexer and requires some configuration, is shown below.

### Book
{Chapter bookChapter = (Chapter) parent()}
To write a book, such as this thesis, we need a more complex document class.
To write this thesis we created a new document class that represents the {lat} template for a thesis.

In this case the template is implemented in the `Thesis` class given below.
To reuse as much functionality as possible, it extends the `Document` class.
It adds its own packages and required elements, such as a title page, and it creates its own {lat} preamble.
The code for this is shown below, the preamble is not shown entirely as it is very long.
{
    Ranges bookRanges = new Ranges().add(19, 42).add(53, 69).add(114, 115);
    new LstInputListing(bookRanges, '''../../examples/0.8/lib/neio/thesis/Thesis.no''')
}

In the above code we also tell the document class to not create `Chapter`s, but instead create `ThesisChapter`s.
A `ThesisChapter` redefines a chapter such that a level one chapter is translated to a {lat} `chapter` instead of a {lat} section.
This is done through the following line.
{
    new LstListing('''addClassMapping(Chapter.class, ThesisChapter.class);''')
}

The document class also provides a method that initialises the main matter, which contains a Table of Contents (ToC) using the following line.
This is a method that has to be called in the Neio document when the main matter begins.
It is a separate method to allow us to easily add content, such as an abstract, before the main matter.

### Abstract
{Chapter abstractChap = (Chapter) parent()}
The abstract used in this thesis is written in a separate Neio document \(`overview.no`).
It uses the `Abstract` document class and is included in this document by the following line.
{
    new LstInputListing(5, 5, '''../../examples/0.8/input/thesis/thesis/thesis.no''')
}

The first part of the Neio document for the abstract is shown below.
{
    new LstInputListing(1, 13, '''../../examples/0.8/input/thesis/thesis/overview.no''')
}

As shown in the code above, the parameters for the `Abstract` are passed through symbol methods.
To do this, `Abstract` overrides the `newline` method such that it creates an `AbstractNLHandler`.
The `AbstractNLHandler` defines the `\|`, `\-` and `\*` methods.
It also overrides the `newline` method to return the control of newlines back to the enclosing `Content`.
The code for the `\-` and `\|` methods is shown below.
{
    new LstInputListing(22, 58, '''../../examples/0.8/lib/neio/thesis/AbstractNLHandler.no''')
}

The implementation of `\|` is not perfect and the way to handle such scenarios should be changed in the future.
Is is not perfect as the user has to use if statements to check what parameter should be filled in.
If the user forgets a parameter the layout will be wrong, but no exception or warning is given.
Finally, all of the parameters are passed as `Text`. When a we enter a name for example, we do not know what part is the first-, middle- or surname.
However, this information might be important. For example, often only the first letter of a first name is displayed.

We could also have set the parameters using a code block and calling setters defined in `Abstract`.
However, this seemed like a more elegant way.

## Libraries
{Chapter libraries = (Chapter) parent()}
To demonstrate what the strength and flexibility of Neio a few libraries were created or reimplemented.
All of the currently available libraries in Neio are explained below.

Note that none of these libraries are complete and it would require a lot more effort to reach a state of completion.
For example, if we have a look at the manual of a popular library such as TikZ{cite('''tikzman''')}, we see that more time is needed to write such a library than there is available for this thesis.

### BibTeX
The library created for BibTeX is one of the easiest ones created using Neio.
The implementation is actually a binding to {lat} and does not allow for a lot of customisation as we do not have an object model of the BibTeX file.

The first reason we chose to implement BibTeX this way, is to illustrate that creating a binding for a {lat} package is not difficult.
The second reason is that we would have had to create an entire BibTeX parser to create a complete object model of the BibTeX files.
As the BibTeX format is quite complicated we felt that our time was better spent elsewhere.

The important code for our implementation of BibTeX can be found below.
{
    new LstInputListing(21, 41, '''../../examples/0.8/lib/neio/stdlib/Bibtex.no''');
}

The `toTex()` method creates the {lat} representation of a `Content`. This method is further discussed in Chapter 4.

A BibTeX file can now be added through the `addBibtex` method and we can cite an entry by using the `cite` method.
These methods are both implemented in `Document` and are shown below.
{
    new LstInputListing(73, 97, '''../../examples/0.8/lib/neio/stdlib/Document.no''');
}

The `Citation` class is a subclass of `Text` as we call it through an inline code block. This is shown below.
{
    new LstListing('''
[Document]
This is how we cite something {cite(\u0027''key\u0027'')}.
    ''')
}

The argument `key` is a Java String, as it is used to do a lookup on the BibTeX entries. It is thus not allowed to be marked up.

### References
The way references have been implemented is quite straightforward.
Any class that implements the `Referable` interface, such as `Chapter` or `Image`, can be referenced by calling the `ref` method defined in `Referable`.
An example of referring to a chapter is shown below.
{
    new LstListing('''
[Document]
# Chapter 1
{Chapter chap = (Chapter) parent()}

In {chap.ref()} we explain references.
    ''')
}

The example makes use of the `parent` method, defined in NLHandler, to put the newly defined `Chapter` in a method.

A `NLHandler` takes the object that created it as a parameter in its constructor so that it can refer to it later on.
The `newline` method of a `Chapter` is defined in `TextContainer` (the super class of `Chapter`).
The `parent` method in the example thus returns a `TextContainer`, hence the cast to `Chapter`.

To reference an object, {lat} needs a unique label.
We use the hashcode of an object for this as it is unique and easy to retrieve at any time.
The `ref` method defined in `Chapter` and the `Referable` interface are shown below.
{
    LstInputListing refEx = new LstInputListing(117, 134, '''../../examples/0.8/lib/neio/stdlib/Chapter.no''');
    return refEx;
}
{{
    new LstInputListing('''../../examples/0.8/lib/neio/lang/Referable.no''').rightOf(refEx)
}}

As we need a variable to reference something, this means that the object we want to refer to has to be available when we want to refer to it.
This means that we can not refer to things that are defined later on in the project, which {lat} can do.

{lat} is able to do this because it compiles more than once and is able to gather the information needed to create a reference in one of the earlier runs.
To do this in Neio, we would have to hold of creating the reference until the document is completed.

### {lat} math and amsmath
{Chapter mathChap = (Chapter) parent()}
{lat} is very good at typesetting mathematical formulas. As such we could not forget about it.

Two ways to make use of the {lat} math and the amsmath package have been created.
The UML diagram below shows the most important classes in the Neio math library.
{
    List<String> umlMath = new ArrayList<String>();
    umlMath.add('''neio.stdlib.math.Eq''');
    umlMath.add('''neio.stdlib.math.InlineEq''');
    umlMath.add('''neio.stdlib.math.Sqrt''');
    new Uml('''./project.xml''','''neio.stdlib.math''').show(umlMath)
}

An inline math formula in {lat} is created by surrounding a formula with a pair of `\ $`'s.
In Neio, we can create inline math using an inline code block.
We can also wrap the code block with a `\$` surround method that does nothing, to make it look like inline math in {lat}.
However, this does not offer any new functionality and it is thus not done in this example.

The only method that has been implemented for this class is `sqrt`, so we show how we can create an inline square root.
{
    new LstListing('''
{
    Integer base = 2;
    Integer arg = 10;
}
The square root of {arg} is {ieq().sqrt("{base}", "{arg}")}.
''')
}

The `ieq` method, defined in `Document`, creates an `InlineEq`.
On this object, we call the `sqrt` method.
However, the `sqrt` method has `Text` arguments.
To transform the `Integer` variables to `Text`, we enter text mode and open an inline code block that returns the variable.
A solution to this problem is proposed in Chapter 5.3.

It is also possible to explicitly create an equation, in {lat} this is done using the `equation` environment.
An example of how to create this in Neio is shown below.
{
    Image mathExample = new LstListing('''
{{
    eq().nonu().sqrt("{base}", "{arg}");
    eq().^("{base}", "{arg}").=().v("{Math.pow(base, arg)}");
}}
    ''').leftOf(image("The rendered form of the example to the left.", '''mathExample'''))
}

The code above creates two `Equation`s.
We disabled numbering on the first one through the `nonu` method and called sqrt on it.

In the second equation we use the `\^` method to create an exponentiation and use the `\=` method to create an equation.
The `v` method creates a `Value` and calculates the actual value of what has been typeset before it.
To be clear, everything except for the `Math.pow()` typesets something, but computes nothing.
This can be clearly seen in {mathExample.ref()}.

### {lat} tables
Tables are one of the main things missing in {md}, and are one of the things people have the most problems with in {lat}.
In this section we explain how the table shown in {newlines.ref()} was built.

To create tables, we created a DSL that is readable in text mode and that allows you to easily edit values in the table later on.
The latter is important because customising table elements inline, as is done in {lat}, makes a table hard to read.

The table is created as an ASCII table, with pipes, spaces, dashes and values for the elements of the table.
The example shown in {newlines.ref()} is repeated below.
{
    LstListing tableExDSL = new LstListing("An ASCII table created in Neio.", '''
|      Student club      | Rounds | Seconds/Round | Dist (km) | Speed km/h | 
---------------------------------------------------------------------------- 
| HILOK                  |  1030  |      42       |   298,70  |   24,89    | 
| VTK                    |  1028  |      42       |   298.12  |   24.84    | 
| VLK                    |   841  |      51       |   243.89  |   20.32    | 
| Wetenschappen and VLAK |   819  |      53       |   237,51  |   19.79    | 
| VGK                    |   810  |      53       |   234.90  |   19.58    | 
| Hermes and LILA        |   793  |      54       |   229.97  |   19.16    | 
| HK                     |   771  |      56       |   223.59  |   18.63    | 
| VRG                    |   764  |      57       |   221.56  |   18.46    | 
| VEK                    |   757  |      57       |   219.53  |   18.29    | 
| VPPK                   |   689  |      63       |   199.81  |   16.65    | 
| SK                     |   647  |      67       |   187.63  |   15.64    | 
| Zeus WPI               |   567  |      76       |   164.43  |   13.70    | 
| VBK                    |   344  |     126       |    99.76  |    8.31    | 
    ''');
    return tableExDSL;
}

|      Student club      | Rounds | Seconds/Round | Dist (km) | Speed km/h | 
---------------------------------------------------------------------------- 
| HILOK                  |  1030  |      42       |   298,70  |   24,89    | 
| VTK                    |  1028  |      42       |   298.12  |   24.84    | 
| VLK                    |   841  |      51       |   243.89  |   20.32    | 
| Wetenschappen and VLAK |   819  |      53       |   237,51  |   19.79    | 
| VGK                    |   810  |      53       |   234.90  |   19.58    | 
| Hermes and LILA        |   793  |      54       |   229.97  |   19.16    | 
| HK                     |   771  |      56       |   223.59  |   18.63    | 
| VRG                    |   764  |      57       |   221.56  |   18.46    | 
| VEK                    |   757  |      57       |   219.53  |   18.29    | 
| VPPK                   |   689  |      63       |   199.81  |   16.65    | 
| SK                     |   647  |      67       |   187.63  |   15.64    | 
| Zeus WPI               |   567  |      76       |   164.43  |   13.70    | 
| VBK                    |   344  |     126       |    99.76  |    8.31    | 

Note that the table above is created using the syntax in {tableExDSL.ref()}, and is not an image that was included in the document.
In fact, all of the examples shown from here on out, until the end of this chapter, are created using the DSLs demonstrated in said examples.

First of all, we note that it does not matter how many spaces are placed inside the elements of the table.
The DSL for this table uses of the symbol method `\|`, a nested method `\-` and a new `NLHandler`.

The first `\|` method is defined in `TextContainer`, so that it can be used in `Chapter`s as well as `Document`s (they are both subclasses of `TextContainer`).
It is shown below
{
    new LstInputListing(107, 120, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''');
}

The `TableRow` that is returned form the the `\|` method is a row that is still under construction.
By continuously calling `\|`, we are able to construct the entire row.
This is the reason why we mentioned that symbol methods could be called after another symbol method in {symbolChap.ref()}.

The `\|` method that builds the `TableRow` is defined in `TableRow`, and is shown below.
We also show the `\|` method without arguments. It defines the end of a row.
{
    new LstInputListing(26, 34, '''../../examples/0.8/lib/neio/stdlib/TableRow.no''');
}

The `newline` method defined in `TableRow` returns a `TableNLHandler`.

This handler defines the `\-` nested method and the `\|` symbol method.
The former creates a horizontal line in the document and disregards the nesting level.
This level could however be used to determine the width of the table for example.
The latter is used to start the construction of a new `TableRow`.

The code for the `\-` and `\|` methods defined in `TableNLHandler` is shown below.
{
    new LstInputListing(30, 48, '''../../examples/0.8/lib/neio/stdlib/TableNLHandler.no''');
}

Finally we can write an empty newline to return control of newlines to the enclosing `Content`

The libraries that are discussed in the next sections are domain specific and show how versatile Neio can be.

### Red black trees
{Chapter rbtChap = (Chapter) parent()}
Red black trees are trees that are constantly update according to a defined algorithm.
When we want to show a red black tree in {lat}, we can typeset an instance of such a tree using for example `TikZ`.
We could also create it in a third party program and include an image of the instance in our document. This solution also works for {md}.

However, since an algorithm is used, and we have a programming model, could not we just build the tree and then display it?
Yes we can! All we have to do is take some code that can generate red black trees, and add a display method to it.
We show an example of the red black trees in use below.
{
    new LstInputListing('''../../examples/0.8/input/testInput/rbtDocument/rbtDocument.no''');
}

{
    List<Integer> tree = new ArrayList<Integer>();
    tree.add(33);
    tree.add(15);
    tree.add(10);
    tree.add(5);
    tree.add(20);
    tree.add(18);
    tree.add(47);
    tree.add(38);
    tree.add(36);
    tree.add(39);

    String numbers = '''''' + tree.get(0);
    for (int i = 1; i < tree.size(); i = i + 1) {
        numbers = numbers + ''', ''' + tree.get(i);
    }
    Integer dumpStub = 0;
}

Given the red black tree of {numbers}
{
    RedBlackTree rbt = new RedBlackTree().insert(tree);
    return rbt;
}

Add 37
{
    RedBlackTree rbt2 = rbt.insert(37);
    return rbt2;
}

Add 51
{
    RedBlackTree rbt3 = rbt2.insert(51);
    return rbt3;
}

This code allows us to very easily create and show red black trees.
Of course, we are not limited to red black trees. This can be done for any tree or graph, as long as we have code for it and write a method
that can display it.

To compare our method to typesetting every instance of the tree in {lat}, we show the {lat} code for the first instance of the tree.
This code is not that easy to read, hard to write and prone to syntax errors.
For example, this code is newline sensitive, placing empty newlines between the entries throws a syntax error at compilation.
The code for the next instance of the tree is very similar, but it is hard to reuse this code.
{
    new LstInputListing('''rbtLatex.tex''')
}

Note that this tree is not implemented optimally, when we append a new value to the tree in our implementation, we
completely clone the tree and add a new node to this new tree. The red black tree in this example also
only works for integers.

The reason we clone the tree every time we insert a new value is because otherwise the three trees would be
represented by the same object. They would thus all show the latest version of the tree.
This problem is discussed in Chapter 5.

### MetaUML
{Chapter umlChap = (Chapter) parent()}
The next example has already been used in {mathChap.ref()}.
Every UML diagram in this document is created using the UML library discussed in this section.

It is also a little different from the other libraries we have seen thus far as it does not directly translate into {lat}. Instead we are making use of MetaUML {cite('''metauml''')}.
How this works exactly is shown in Chapter 4. For now, it is enough to know that the object model build by this library is output as a string that is understood
by `MetaUML`. `MetaUML` then creates a MetaPost file {cite('''metapost''')} which is included in the document.

In this section, we give a high-level overview of how we create UML diagrams. We start out with an example.
{
    new LstListing('''
[Document]
{
    new Uml(\u0027''./project.xml\u0027'', \u0027''neio.stdlib.graph\u0027'')
}
    ''')
}
{
    new Uml('''./project.xml''','''neio.stdlib.graph''')
}

This code reads the `project.xml` file that tells it what project we want to create an UML diagram for.
The second parameter is the namespace the UML diagram should be created for.
This means that the UML diagram in this example is created from the *actual* classes that make up this document.

When the document is compiled, the Neio code files are read and an object model of said files is created.
This model is then used to visualise the files as the UML diagram seen above.

It is also possible to only show a few classes, or to also show private and protected members.
This is shown in the example beneath.
{
    new LstListing('''
[Document]
{
    List<String> list = new ArrayList<String>();
    list.add(\u0027''neio.stdlib.uml.Uml''\u0027);
    list.add(\u0027''neio.stdlib.uml.UmlClass''\u0027);
    new Uml(\u0027''./project.xml\u0027'', \u0027''neio.stdlib.uml\u0027'').scale(80).show(list).showAll();
}
    ''')
}
{
    List<String> firstList = new ArrayList<String>();
    firstList.add('''neio.stdlib.uml.Uml''');
    firstList.add('''neio.stdlib.uml.UmlClass''');
    new Uml('''./project.xml''','''neio.stdlib.uml''').scale(80).show(firstList).showAll();
}

In this example, the UML diagram shows two of the *actual* classes that were used to create this UML diagram.

Because Neio is compatible with Java, we can use any Java code in a document. In this case, we reuse a class created for the Neio compiler from within a
Neio document to create an object model of Neio source code. Once the object model is created, we can query and modify it. 
Because of this object model, we can query the model without having to know the language semantics of Neio. The architecture of Chameleon thus allows 
the same UML library to be used to generate diagrams for any object-oriented language that is developed using Chameleon.

How this works exactly is explained in Chapter 4.

As the code for this library is over 600 lines long, we do not show all of the code.

The problem with the MetaUML tool is that positioning is not done automatically.
The way we implemented positioning is like a tree.

We build a tree of levels. The first level contains all the classes that have no super class to be shown as well as the highest level classes.
Subclasses are shown on the level beneath their super class.

For example, `ThesisChapter` is a subclass of `Chapter`, which is a subclass of `TextContainer`.
If we now show these three classes, they are displayed one under the other because we built a tree with 
three levels.

To visualize how the levels are being used, we show this example below and also add the Bibtex class 
to the UML diagram to show what happens to classes that have no connection to the other classes.
{
    List<String> list2 = new ArrayList<String>();
    list2.add('''neio.thesis.ThesisChapter''');
    list2.add('''neio.stdlib.Chapter''');
    list2.add('''neio.stdlib.TextContainer''');
    list2.add('''neio.stdlib.Bibtex''');
    new Uml('''./project.xml''','''neio''').scale(80).show(list2).showPrivate();
}

Note that our implementation of UML diagrams only shows what it is asked to show (hence there are no uses 
arrows) and only draws inheritance arrows for what is shown. These arrows are only shown for direct super classes.
This is done to avoid clutter.

### Chemfig
In this example, we approach a different domain, the domain of biology and chemistry.
For this domain, we created a library and DSL to create structural formulas.
An example of the structural formula for glucose is given below.
{
    new LstListing('''
[Document]
{
    new Structure()
}

$ C * 6 _ OH ^ - C _ ^ OH - O - C _ ^ CH2OH - C _ HO ^ - C _ ^ OH - 
| Glucose
    ''')
}

This example produces the following output
{
    new Structure();
}

$ C * 6 _ OH ^ - C _ ^ OH - O - C _ ^ CH2OH - C _ HO ^ - C _ ^ OH - 
| Glucose


The first thing we see, is that we create a new `Structure`.
This provides a newline handler that allows us to instantiate structure formulas using the `\$` method and captions for them using the `\|` method.
The `\$` method shown below, creates an atom and adds it to the structure, the rest of the structural formula is then build by chaining atoms together.
{
    new LstInputListing(18, 23, '''../../examples/0.8/lib/neio/stdlib/chem/StructureNLHandler.no''');
}

The `\*` method call, followed by a number, defines that the formula is a ring. The number defines the number of edges of this ring.
The `\-` method creates a single link from the previous atom to the next, `\=` creates a double link.
Finally, the `\^` method defines that the next atom is above the previous one, while `\_` puts the next atom below the previous one.
The code for one of these is found below.
{
    new LstInputListing(79, 88, '''../../examples/0.8/lib/neio/stdlib/chem/Atom.no''');
}

The `toTex` method returns a {lat} representation of the structure that is understood by the {lat} package `chemfig` {cite('''chemfig''')}.

### Lilypond
{Chapter lily = (Chapter) parent()}
For the last example, we create sheet music.
An example musical score is shown below.
{
    LstListing lilyEx1 = new LstListing("An example musical score.", '''
[Document]
{
    Score s = new Score().a().b().c(1).d(1).e(1).f(1)
        .g(1).f(1).e(1).d(1).c(1).b().a()
        .g().f().e().d().c().b(- 1).a(- 1);
    return s;
}
''');
    return lilyEx1;
}
{
    Score s = new Score().a().b().c(1).d(1).e(1).f(1)
        .g(1).f(1).e(1).d(1).c(1).b().a()
        .g().f().e().d().c().b(- 1).a(- 1);
    return s;
}

In this DSL, a class has been made to represent a note and a method is available to create every note.
For example, to create the note `C`, you call the method `c()`.
The integer that can be passed to a note, lower or heightens the octave of the note.

Every operation that would modify the current `Score`, first copies the `Score` to make sure that we do not edit any of the already placed scores.

The code to add the `C` note to a `Score` is given below.
{
    Ranges lilyRanges = new Ranges().add(15, 15).add(89, 98).add(133, 141);
    new LstInputListing(lilyRanges, '''../../examples/0.8/lib/neio/stdlib/music/Score.no''');
}

We can now query the notes of this score, for example `\{s.get(8)\}` gives us the eighth note.
Doing this for our example tells us that the eighth node is {s.get(8)}.

It is also possible to reverse a score or shift it up or down using the `reverse` and `shift` methods respectively.
The sequence of notes can also be printed using the `print` method.
These methods are demonstrated in the example below.
{
    Score ss = new Score().c().d().e().f().g().a().b();
    return ss;
}

This score is read as {ss.print()}.
{
    Score sss = ss.shift(1);
    return sss;
}

We can shift every note by one, doing so yields the following notes: {sss.print()}.
{
    Score s4 = ss.reverse();
    return s4;
}

Reversing the score results in the following sequence of nodes: {s4.print()}

The code for this example as well as the implementation of the `reverse` and `shift` methods is given below.
{
    LstInputListing lilyEx2 = new LstInputListing(50, 75, '''../../examples/0.8/lib/neio/stdlib/music/Score.no''');
    return lilyEx2;
}

{{
    new LstListing("The code of the example.", '''
{
    Score ss = new Score().c().d().e().f().g().a().b();
    return ss;
}

This score is read as {ss.print()}.
{
    Score sss = ss.shift(1);
    return sss;
}

We can shift every note by one, doing so yields the following notes: {sss.print()}.
{
    Score s4 = ss.reverse();
    return s4;
}

Reversing the score results in the following sequence of nodes: {s4.print()}
    ''').rightOf(lilyEx2);
}}

To typeset these music sheets, the object model is written out in a format that is understood by `LilyPond` {cite('''lilypond''')}.
This is written to a file and the file is passed to the `lilypond` command line tool.
This tool generates a PDF that is then inserted as an image in the document.

# Implementation
{Chapter implementation = (Chapter) parent()}
To use Neio, we also had to build a compiler.
How we implemented it, as well as some lower level concepts used in Neio code files, is explained in this chapter.

## Compile process
{Chapter compProcess = (Chapter) parent()}
We start out by showing a diagram that depicts the process a source file goes through Neio source code up to the final {lat} file.
{
    Image compileFlow = image("The process of compiling Neio source code to LaTeX.", '''CompileFlow''');
    return compileFlow;
}

First of, the Java and Neio library (the Neio code files) are read by the front end of the Neio compiler and translated into a Concrete Syntax Tree (CST).
This CST is created by the parser and lexer that were generated by ANTLR4. The CST is then visited using the visitor pattern and an Abstract Syntax Tree (AST) is build.

The AST contains objects provided by Jnome and Chameleon.
It is then passed to the middle end of the compiler and transformed to an object model that can be output to valid Java code.
The transformed AST and the ASTs for the Neio library are passed to the compiler back end which generates the final Java code.

This generated Java code is then compiled and executed again.
During the execution, resources might be created, if so, they can be used in the next step.

The last step uses the Neio library to create a {lat} file of the created object model.

## Used libraries and frameworks
In the previous section we mentioned three libraries/frameworks that were used to successfully compile the document.
They are discussed in more detail in this chapter.

### ANTLR4
{Chapter antlr4C = (Chapter) parent()}
The ANTLR4 {cite('''antlr4''')} library is an open-source parser generator released under the BSD license.
It is used to parse all of the Neio files, the Neio documents and the Neio code files.

We used ANTLR4 in the following way.
First we created two grammars, consisting of a lexer and a parser, for the Neio documents and classes, thus four files in total.
They are written using the ANTLR4 DSL.
An example of the parser rule that describes the class definition and the lexer tokens that it uses are shown below.
{
    LstInputListing antlrParser = new LstInputListing(16, 19, '''../src/main/grammar/ClassParser.g4''');
    return antlrParser;
}
{{
    Ranges r = new Ranges().add(11, 15).add(48, 48).add(85, 85).add(88, 88).add(92, 92);
    antlrParser.rightOf(new LstInputListing(r, '''../src/main/grammar/ClassLexer.g4'''));
}}

These are then fed to the `antlr4` command line tool.
This tool generates Java classes using the grammars you defined.
These classes are compiled and then used to visit the Concrete Syntax Tree of a file using the visitor pattern.

Whilst visiting every rule and terminal, we build an Abstract Syntax Tree (AST) for the given file.
This tree can then be manipulated in later stages.

The UML diagram for the auto-generated java classes \(`ClassParserBaseVisitor` and `DocumentParserBaseVisitor`\) and our visitor implementations \(`ClassConverter` and `DocumentConverter`\) are illustrated below.
Note that this is a shortened version, not all the methods are shown.
{
    image('''visitor.1''')
}

The code to visit an inheritance relation is shown below as an example.
{
    new LstListing('''
@Override
public SubtypeRelation visitInheritance(InheritanceContext ctx) {
    SubtypeRelation relation = ooFactory().createSubtypeRelation(visitType(ctx.type()));
    if (ctx.IMPLEMENTS() != null) {
        relation.addModifier(new Implements());
    }

    return relation;
}
    ''')
}

The objects that are used in the AST are objects defined in Jnome and Chameleon.
These object, in combination with the ANTLR4 grammars and visitor classes, thus form the front end of our compiler.

### Chameleon and Jnome
{Chapter chamJnome = (Chapter) parent()}
Chameleon and Jnome are both projects that were developed by professor van Dooren and released under the MIT license.

Chameleon {cite('''chameleon''')} {cite('''chameleonPaper''')} is a framework for defining abstract ASTs of software languages. It enables
the reuse of generic language constructs and the construction of language-independent development tools.
It does so by defining language-independent objects \(`Element`, `CrossReference`,...\)
as well as paradigm-specific ones \(`Type`, `Statement`, `Expression`,... for Object-Oriented Programming).

Jnome {cite('''jnome''')} is a Chameleon module for Java 7. It extends the objects available in Chameleon with Java-specific objects.
It is a front end for the Java language because it can read Java code and build an AST from it (using ANTLR3).
It is also able to output Java code for a given an AST consisting of Jnome and Chameleon objects.
This part is the back end of the Neio compiler.

The Chameleon architecture is shown below.
The UML editor shown in the diagram is the one explained in {umlChap.ref()}.
{
    Image chamArch = image("The Chameleon architecture.", '''architecture''');
}

Jnome can read entire Java projects at once, in our compiler for example, it loads the entire Java library.
This is needed because our objects use Java objects, such as `String`s.
It reads all of the source files and libraries that are specified in a file called `project.xml`.
This was mentioned earlier in {umlChap.ref()}.
The same file is used to read Neio projects in our compiler. The `project.xml` for the Neio compiler is shown below.
{
    LstInputListing projectXml = new LstInputListing('''project.xml''');
    return projectXml;
}

In {umlChap.ref()} the following is happening.
First, the Neio compiler reads the Java library as well as the code of the Neio standard library, Neio compiler, Chameleon and Jnome.
Which libraries to read exactly is shown in `project.xml` as is shown in {projectXml.ref()}.
Then the Java code is generated and executed.

During this execution, the `Uml` class reuses code from the Neio compiler to repeat the process of reading these libraries.
This is possible because of the Java compatibility of Neio.
It can now create a UML representation of anything it read in the previous step.

The libraries can be read using the following two lines.
{
    new LstListing('''
NeioProjectBuilder projectBuilder = new NeioProjectBuilder();
JavaView view = (JavaView) (projectBuilder.build(projectXml));
    ''')
}

The `projectBuilder` does some initialisation and loads the `project.xml`.
The `view` contains all of the namespaces, classes,... that were read.

Chameleon also provides IDE support for the code mode (syntax errors and highlighting, project outline, dependency analysis,...) as is shown below.
{{
    image("A code file with syntax highlighting, a syntax error and a dependency view.", '''ide''')
}}

This support is enabled through only a few lines of code (shown below).
This is because the IDE support is language-independent, as can be seen in {chamArch.ref()}.
{
new LstListing('''
public class Bootstrapper extends EclipseBootstrapper {
    public Language createLanguage() throws ProjectException {
        Neio result = new NeioLanguageFactory().create();
        result.setPlugin(EclipseEditorExtension.class, new JavaEditorExtension());
        result.setPlugin(DependencyOptionsFactory.class, new JavaDependencyOptionsFactory());
        return result;
    }
}''')
}

Next to this code, we also have to add a few configuration files: `plugin.xml`, `build.properties` and `META-INF/MANIFEST.MF`.
We also have to add an `xml` directory which is used for syntax highlighting.
These files can be reused for another language as well.
This only requires us to fill in the name of the plugin and the extension of the language in these files.

Of course the compiler also has to fill in position information, but this is needed to create comprehensive error messages anyway.

Having obtained an AST in {antlr4C.ref()}, we now manipulate it in the middle end of our compiler.
The transformed AST is then output to Java using the Jnome back end.

## Translation
### Reasons for choosing Java
The reason we chose for Java was multi-fold. First and foremost, we already had a front and back end available
for Java thus this saved us a lot of time.

A second reason is because Java is platform independent which does not restrict us to a single operating system.
Java is also very popular in the computer science world {cite('''ieeejava''')}, which is why we chose to base our code mode on it.
This popularity is very important as it gives us a large user base that can read and understand code mode, but we are also able to reuse Java libraries.
Because of said popularity, a lot of libraries already exist, which dramatically improves the possibilities of Neio.
For example, it is possible to use a library that tests your network connection, and directly include the results in a Neio document.
In TeX this is also possible, but because it is so hard to use the programming model and because there are only so little TeX developers,
almost no libraries of this kind are available.

### Fluent interface
We tried to make use of fluent interfaces as much as possible.
In the design of the language we did this by using method chains, but we also tried to use it in the libraries we implemented in {libraries.ref()}.
We chose to do this as it imposes less boilerplate code (less variable declarations) and because it is clearer to read what we are building.
Instead of passing a ton of arguments to one method, we split it up in multiple methods and build a single object.

### Translation to Java
{Chapter javaTrans = (Chapter) parent()}
Neio makes use of context types, which is a new concept.
This means we had to create a custom translation for it.
The way we choose to translate this, is by breaking up the method chains created in the Text mode of a Neio document at every method call.
A variable is then assigned to the output of this method call.

To know what to call our method on, `ContextType` was implemented as a subclass of the `RegularJavaType` class in Jnome.
A `RegularJavaType` is what we know as a Java class.

We also created a `NeioMethodInvocation` which creates a `ContextType` when its type is queried.
The constructor of `ContextType` takes two `Type`s as arguments. The first one is the actual return type of the method, the second one is the context of the the method.
The `ContextType` then adds the two `Type`s as super classes. so that it can access there methods.

When a lookup is done on a `ContextType` it first checks the actual type and then the context.
Lookups are provided by Chameleon and explaining how exactly they work is out of the scope of this Thesis.

The lookup on a `NeioMethodInvocation` now returns the correct type, but we still have to find which variable corresponds to this type.
To implement this we add every variable that is declared to a stack. To find the correct variable we iteratively pop the stack until a variable with the correct type is found.

Lastly, we also have to translate `this` as we saw in {thisCode.ref()}.
All we have to do for this, is replace `this` with the last defined variable and go through the above process again.

The complete translation to Java is shown below.
{
    LstInputListing ctxExample = new LstInputListing('''../../examples/0.8/input/testInput/testInput/testInput.no''');
    return ctxExample;
}
{{
    ctxExample.leftOf(new LstListing('''
new Document()
    .newline()
    .newline()
    .#("Chapter 1")
    .newline()
    .text("This is some text in the first Paragraph");
    '''))
}}
{
    LstInputListing compTrans = new LstInputListing('''testInput/testInput.java''');
    return compTrans;
}

The complete translation is given in {compTrans.ref()}.
The middle end has created three methods. The first one is the main method, it allows the document to be executed as a whole.
It initialises the document class and then calls `createDocument` which actually creates the object model that represents the document.
Finally `finishDocument` compiles the document to {lat} and compiles that to a PDF.

The reason we split up this process is so that we can call the creation of the document separately which allows us to include documents.
To do this we call the `createDocument` method with an appropriate argument, we saw this in action in {abstractChap.ref()}.

The middle end also imported every namespace in the Neio library as well as the `java.util` namespace as those usually needed.
The name of the Java class that is generated is the same as the name of the Neio document.

### Reflection
{Chapter reflection = (Chapter) parent()}
In {bookChapter.ref()}, we used `addClassMapping` to tell the document class to create `ThesisChapter`s instead of `Chapter`s.
This method is used to tell a `Content` to create specialized versions of a certain `Content`.
It solves the same problems that factories solve.
The reason we did not use actual factories is because we did not want the user to write them.
Factories are usually straightforward and similar to each other, yet not reusable.

Every `Content` has a class mapping that is initialised as an empty map.
To use a specialized version of a class, you add a mapping from the generic class to the specialized class.

The middle end of the compiler swaps out every new call to a `Content` in a `Content` by a call to `getInstance`.
This method checks if there is a mapping for the generic class in this `Content`, or any of its parents.
If there is, then an instance of specialized class is created. If not, an instance of the generic class is generated.
The instances are created through reflection.
The code for `getInstance` and the class mappings is shown below.
{
    Ranges reflectionRanges = new Ranges().add(17, 18).add(339, 401);
    new LstInputListing(reflectionRanges, '''../../examples/0.8/lib/neio/lang/Content.no''');
}
{
    new LstListing('''Chapter chapter = getInstance(Chapter.class, new Class[]{Text.class, Integer.class}, new Object[]{title, 1});''');
}

We explain this again using the example below.
{
    new LstListing('''
[Document]
# Chapter 1
{
    nearestAncestor(Document.class).addClassMapping(Enumerate.class, FibEnumerate.class);
}
    ''')
}

We added a mapping from `Enumerate.class` to `FibEnumerate.class` in the root `Document`.
When we now call `getInstance(Enumerate.class, ...)`, the root of the call is `Chapter`, not `Document`.
But as said before, `getInstance` also checks the parents for class mappings. We first check if a mapping is available in `Chapter`.
As there is none, we recursively check the mappings of our parents. The mapping is found in the first parent, `Document`, and thus we create an instance of `FibEnumerate` one of `Enumerate`.

### Escaping
A Neio document is parsed and converted a number of times. First, it is parsed by the Neio compiler, then 
it is transformed into Java code that is then converted into {lat} code (in most cases).
This means that we have to handle escaping of characters in three different languages.

In code mode, the same escaping rules as in Java are applied.
In text mode, escaping is easy. Adding a `\\` before a character escapes it. Of course, `\\\[nutr\]` hold on to their 
special meaning. However, `\\\[bf\]` have not been included in Neio as they are not yet needed. In the future it might 
prove useful to include them too.

We can not just translate these characters straight to Java as we have no special meaning for `\\\[bf\]`.
For this reason, the middle end transforms every backslash into two backslashes, and transforms a double backslash (denotes an 
escaped single backslash in Neio) to four backslashes in Java (this is how you represent an escaped backslash in a Java String).

We then do some further translation in the `Text` class to assure that it creates valid {lat}.
{lat} only has ten special characters thus translation is quite easy. This translation code is shown below.
{
    new LstInputListing(170, 192, '''../../examples/0.8/lib/neio/lang/Text.no''')
}

`ESC` is an escape sequence. It is used to prevent the second replace from adjusting the changes made in the first replace.

## Resource usage and creation
{Chapter rsc = (Chapter) parent()}
A document often uses resources such as images or other documents.
To include them in the final {lat} document, they have to be available in the same folder as the {lat} source code.
We make sure that these resources are available by copying every file that does not use the `.no` extension from the source folder to the output folder.

As mentioned in {compProcess.ref()}, it is also possible to create resources at compile time of the auto-generated Java code.
To create resources we can use writers and builders.
A writer writes a string to some sort of output, such as a file or stdout.
A builder takes a filename and executes a command on the file.
Extra arguments for the builder or writer can be passed through their constructor.

A writer and builder are also used to create the {lat} source code of an object model and compile it to the final PDF.
The `TexFileWriter` class takes the {lat} string that was created by calling `toTex()` on the root object of document, and writes it to a file.
The name of the {lat} sources file is equals that of the Neio document.

The `TexToPDFBuilder` class takes the name of the created {lat} file and compiles it to a PDF.
It also cleans up all the unnecessary files that were created during the compilation of the {lat} source file.
To compile the {lat} source code, we use the `latexmk` command.
We chose this command because it automatically compiles the file multiple times if this is needed (for example for references).
The code to build {lat} files is shown below.
{
    new LstInputListing(12, 47, '''../../examples/0.8/lib/neio/io/TexToPdfBuilder.no''')
}

A builder and writer are also used to create the UML diagram in the UML library.
In the `toTex` method of the `Uml` class we first create a string that can be understood by `MetaUML` (by calling the `toMetaUML` method).
This string is then passed to the `MetaUMLWriter` which writes it to a file with the `.mp` extension.
As filename we use a timestamp.

This filename is passed to the `MetaUMLBuilder` which passes it to the `mpost` command.
This command creates an image.

We represent this image using an `Image` object, and call `toTex` on it.
The {lat} representation of this `Image` represents the UML diagram.
It is thus returned as result of the `toTex` method in the `Uml` class.

The `toTex` method of the `Uml` class is shown below.
{
    new LstInputListing(86, 112, '''../../examples/0.8/lib/neio/stdlib/uml/Uml.no''')
}

### Automatic exception handling
To be able to easily make use of IO, or any other code that throws exceptions, the Neio compiler handles exceptions for the user.
When a statement that throws exceptions is found, the compiler wraps it in a try-catch. The body of the catch throws a new `NeioRuntimeException` to make sure that actual exceptions do not go unnoticed.
The automatic catching keeps the code clean, but we have to be careful as it is now less clear that exceptions might occur.

An example is shown below.
{
    new LstListing("A statement in code mode that throws an exception.", '''
Files.write(path, lines);
    ''')
}

{
    new LstListing("The wrapped version of the exception throwing statement.", '''
try {
    Files.write(path, lines);
}
catch (Exception e) {
    throw new NeioRuntimeException("Exception encountered: " + e);
}
    ''')
}

## Translation to {lat}
As shown in the previous section, we use the `toTex` method to create the {lat} representation of an object.
However, this is bad as it adds a dependency towards {lat} on every file.

For example, imagine that we want to create an HTML representation of the objects.
With the current setup, we have to add a `toHTML` method to every object.

For this reason, it would be better to create an external visualiser to output the object model.

## Limitations
During the development of the compiler we encountered a few limitations. They are discussed in this section.

### Java
A limitation that we encountered quite late in the development, was one in Java.
In {javaTrans.ref()}, we mentioned that the creation of the document is realised in the `createDocument` method.
However, the bytecode of a Java function can only be 64 KiB large {cite('''codelength''')}.
As the thesis grew quite long, this limit was exceeded.

To solve this problem `createDocument` would have to split up in smaller methods.
However, this is not straightforward as users can create variables in code blocks.
Statements in a different method might need these variables.

### Windows
In {rsc.ref()}, we saw that commands can be executed.
However, executing commands using the Java `Process` class came with some issues that were not immediately visible.

When developing on Linux, executing shell commands from Java worked flawlessly.
However, on Windows some of the processes would hang. Some always hanged, others hanged only once in a while.

The reason for this, is that Windows offers only a limited buffer size for the input and output streams of a process.
Because of this, the process deadlocks if the input is not written or read.
This became apparent after closer inspection of the Javadoc {cite('''javaprocess''')}, but since the API for the Process class is so simple, it was a surprise nevertheless.
The fact that we have to worry about different platforms on a cross-platform language also came as a surprise.

### Back end
In Java, methods can only contain letters, numbers, `\$` or `\_`. This means we have to translate symbol methods to valid Java identifiers.
This is done in a very straightforward manner.

Using the following mapping, we replace all occurrences of a key in a method or method invocation with the value.
{
    new LstListing('''
"#" -> "hash"
"*" -> "star"
"=" -> "equalSign"
"^" -> "caret"
"-" -> "dash"
"_" -> "underscore"
"`" -> "backquote"
"$" -> "dollar"
"|" -> "pipe"
    ''')
}

# Future work
{Chapter fut = (Chapter) parent()}
As mentioned before in {considerations.ref()}, there are still a few issues that can be fixed in the future.
However, there a lot more things that can be done. We discuss them in the rest of this chapter.

## Automatisation
#### Automatic StringBuilder
Since we are constantly translating to TeX and other formats, we use `StringBuilder` very often.
An example is found in almost every `toTex` method. We show the one defined in `Content` as an example.
{
    new LstInputListing(416, 430, '''../../examples/0.8/lib/neio/lang/Content.no''')
}

In fact, we use it so much that it might be better to just replace `String`s by `StringBuilder`s at all times.
This would allow us to use `+` instead of append, making the syntax more concise.
The performance gain (or loss) of this would have to be investigated though.

#### Automatic return of the object itself
{Chapter autoRet = (Chapter) parent()}
Another pattern that is used often, is that we let methods return the object itself.
As said before, this is to make use of fluent interfaces. An example from the `InlineEq` class is shown below.
{
    new LstInputListing(17, 27, '''../../examples/0.8/lib/neio/stdlib/math/InlineEq.no''')
}

We actually already have a solution for this, constructors.
Constructors do not explicitly tell us what they are going to return, but we know that they return the object itself.
No explicit return statement is needed either. Implementing this for other methods allows us to lower the amount of boilerplate code that has to be written.

#### Automatic Text conversion
The final automation solves the problem we saw in {mathChap.ref()}. The problem was that we had to open an inline code block in text mode to transform a variable to `Text`.
This can be prevented by automatically converting `Content`, or maybe even `Object`, in a generic way.
In Java, this is done through the `toString` method while in Python the `repr` and `str` methods are used for this.

However, if we were to implement in such a naive manner, we would lose any kind of static typing when a `Text` is expected as an argument.
This does not seem like a good thing, especially when you consider that not every object might have a real textual representation.
The latter means that automatically transforming an object to text might often not even create a sensible result.

A better way might be to define an interface, `Representable`, that has a `repr` method. Any class that implements this class, and the native types such as `String` and `Integer`, 
could than be transformed into a `Text` using this `repr` method.

## Static content
In {rbtChap.ref()} and {lily.ref()}, we mentioned that we always had to clone the tree when making changes to it. This is to make sure we are not editing the original tree.

The language does not enforce placed content to be static.
Because of this, it is the responsibility of the library developer and the user of those libraries.
Instead, Neio could enforce this behaviour and take care of the implementation of the clone.

A way that this might be implemented, is by copying objects that are going to be changed through serialization.
This is an expensive operation and thus the performance loss would have to be investigated.

## Remove ambiguity in symbol methods
Symbol methods can use the `\-` and `\=` method and are thus ambiguous with those operators in Java.
To avoid this ambiguity, we could force the user provide an alias for the symbol methods.
In code mode, we would then only be able to use this alias.
This would also make the code more readable as `addChapter` is more informative than `\#`.

## Use
In {reflection.ref()}, we saw that we could specialize what `Content` is made.
However, this is not perfect. It specializes the `Content` for the entire lifetime of the parent, even for instances that were created before we instructed the specialization.
What we actually want to say is: "From here on, use `SpecializedContent` instead of `GenericContent`.".
The use of this `SpecializedContent` would then last from there until the end of the scope of the parent.
It could also be explicitly instructed to stop.

As an example, imagine that we want to use an enumerate that uses the Fibonacci sequence to number its items.
We want to start using it in the middle of a chapter, without it effecting anything that was created earlier.
We also want that anything that is inserted (using code mode) from that point on uses the new enumerate, while anything inserted before it should use the generic enumerate.
{
    new LstListing('''
[Document]
# Chapter 1
* Item 1 // This is a generic Enumerate
* Item 2

{
    use(FibEnumerate.class, Enumerate.class);
}

* Item 1 // This is a FibEnumerate
* Item 2

// End of scope for the first chapter
# Chapter 2 
* Item 1 // This is a generic Enumerate
* Item 2
    ''')
}

Had we used `addClassMapping` to do this, the first `Enumerate` would also be a `FibEnumerate`.

It is possible to implement this as "from now on", but it is not that easy to implement it as "from here on".
Say that after this `use`, we insert an enumerate, using code mode, at the front of the chapter.
The `getInstance` method that initialises the object does not know where the object is going to be placed.
The method that calls `getInstance` can place the initialised object anywhere.
At the time that the initialisation of the object occurs it is thus not known what object should be created.

## Packages
#### Package support
No package system was provided in this thesis, but in the future it would be beneficial to do so.
It would allow users without a lot of technical expertise to import new functionality easily..

The way packaging is handled right now, is straight through {lat} packages and Java packages.
We allow you to add {lat} packages through the `addPackage` method in `Document` and we allow you to import Java classes 
through the regular `import namespace;` statements.

To actually include a Neio library in the document, the source code for the library
has to be put into a folder next to the rest of the standard Neio library. In the future we should be able to download (manually or automatically) packaged libraries 
and have them be stored somewhere else.

#### Implementation of packages
As we said before, non of the document classes or libraries created in this thesis are complete.
In comparison to what Java and {lat} offer, we also did not create a lot of them.

In the future, a lot of work has to be put into writing complete libraries and porting libraries from other available languages such as {lat}.
This can however be done by the community, as is done in Java and {lat}.

We note again, that we can already make use of any of the already existing Java libraries though.

## Compiler improvement
#### Efficiency
The compiler is fast enough for small documents, but for a large document, like this thesis, the compile time starts to ramp up.
The thesis takes about 30 seconds to a minute to compile, depending on the computing power of your computer.
This is on top of `latexmk` and the other commands that have to run afterwards, and that also takes quite a while.

However, no attention was paid to the efficiency of the compiler in this thesis.
It is thus likely that there are a lot of optimisations that can be performed.

#### Other front- and back ends
Another compiler improvement that can be implemented in the future, is that we can create different front and back ends.
We do not have to output to Java. If someone were to write a back end for Python for example, we could make use of that back end.

The same thing is possible for the front end. The syntax of Neio documents and code files can be changed, as long as the fundamental 
design decisions of the language are kept the same. The context types and nested methods come to mind.
As long as the front end can parse the Neio document to the same AST that is used at this moment, it is possible to change the currently used syntax.

## Tool improvement
To effectively be able to use Neio, we need some improvements to the tools available right now.
In {chamJnome.ref()}, we saw that Chameleon provides support for the Eclipse IDE.
This support has been implemented for code mode, but in the future it would also have to be implemented for text mode.

#### Syntax highlighting
Syntax highlighting is one of the base requirements to work with a language..
However, the Chameleon implementation was not made for syntax like the text mode, where we represent a document as a series of method chains.
At this moment, the Eclipse integration treats the entire method chain as a whole instead of every method call separately.
This is problematic because a paragraph that contains inline-code would not be coloured uniformly for example.

#### Auto-completion
A second useful feature that Chameleon offers, is auto-completion.
This works well in code mode, however it is harder to utilize in text mode.
This is because, it hs to know when to auto-complete and when it should just let us write.

It might be best to hide the auto complete behind a hotkey while in text mode.
This still allows the user to get a list of methods he could use at a certain time, but would remove the annoyance of having an auto-completion pop-up at every written word.

#### Outline
The outline offered through Chameleon was implemented for code mode.
However, it is not very useless for text mode. This is because an outline shows the defined members, and in text mode no members are defined.

It would be better if instead we showed the most important elements of the text, such as chapters and images. We could also show the variables that were defined in non-scoped code blocks.

#### IDE with preview
The last thing that would be a nice to have for a markup language like this, is an IDE that previews the document.
This is not something that is supported by Chameleon, and would thus require quite a bit more work.

The compiler in its current state is also not ready for this. As said before it gets quite slow on large documents.
As it would have to be constantly running in the background, it would use a lot of energy (which is problematic for laptops), and would be too slow to actually produce results in real time.

# Conclusion and reflection
#### Summary
In this thesis we researched the current state-of-the-art concerning document creation. From this research we concluded that a good combination of user-friendliness and customisability was hard to find.
To achieve such a combination we created a new markup language, called Neio, that uses a modern, object-oriented programming model.

Two syntaxes were introduced, text mode and code mode. The former is a simple syntax that is used for document creation. The latter allows for customisation of the text mode syntax.
To easily customise this syntax, we developed symbol, nested and surround methods.
Lastly, we extended fluent interfaces to make a user program without him noticing it. The extension is made available through the developed context types.

To prototype Neio, we created a compiler and a standard library. Libraries for different domains were implemented to show the versatility of Neio.
Amongst others, we created a library to create UML diagrams, structural formulas and music sheets.

Finally, we discussed the work that can and should still be done on Neio in the future.

#### Reflection
We used the language for four months (the rest of the time was spent developing it), wrote a Thesis in it and wrote a complete compiler for it.
After all of this, we found that it might have been better to use almost pure Java syntax for the code mode.
We changed a few things, such as adding syntactic sugar for new calls and renaming `package` to `namespace`.
The latter was done because in our eyes, `namespace` is a more general term that better explains what this keyword represents.

However, by choosing different keywords we ended up with name conflicts. At some point in the development we wanted to make use of a class in a package called `namespace`.
This did not work as the parser did not know how to parse a package name containing a keyword.
By changing the syntax as much as we did, it also became impossible to run Javadoc on our code files without making major changes to them.

Disallowing a substantial part of Java (anonymous classes, shorthand operators such as `++` and `+=`,...) also hurts the 
adoption rate of the language as you usually have to invest some time converting a Java file into a Neio file.

We think that it would have been better to have just used Java syntax, with the modifications defined in {methodMods.ref()} for the code mode.
In the future, we might then also add the proposition made in {autoRet.ref()}.

In text mode, it is annoying that we can not use more than one character as a symbol method.
For example, it is not possible to use meaningful symbols such as `->` as a method.

As shown in {abstractChap.ref()}, some work should also be put into making symbol methods more flexible.
It should be possible to easily pass parameters of an object through symbol methods.

#### Conclusion
In the end, we showed that is possible to create a healthy mix between user-friendliness and a powerful programming model.
We showed that the language can be easy to read, write and learn. This was achieved by extending fluent interfaces and basing text mode on {md}, which is already easy to read, write and learn.

We also showed that it can be as powerful and diverse as {lat} whilst remaining quite legible. This was achieved by basing code mode on Java.
The popularity of Java {cite('''ieeejava''')} gives us a large user base that can read and understand code mode.
Because code files are fully compatible with Java, we can also call any Java code from them. We thus have the extra advantage of being able to make use of the enormous Java ecosystem.
The diverse examples showed in {examples.ref()}, and the completion of this book demonstrate the power and diversity of Neio.

A lot of work can still be done, and should still be done to allow the widespread use of Neio, as is shown in {fut.ref()}, but we think that good basis has been provided.
