[Thesis]

{
    addBibtex('''references''');
    String lat = '''LaTeX''';
    String md = '''Markdown''';
    String pan = '''Pandoc''';
}

# Introduction
{Chapter intro = (Chapter) parent()}
In this thesis we will be introducing a new markup language that tries to improve upon a few others, namely {lat} and {md}, whilst still holding on to their advantages.
Before we get into the details of this new language it is necessary to introduce some of the currently most used markup languages and word processors.
This introduction will provide the context from which the necessity of this thesis was sparked.

## State of the art
### {md}
One of the most popular markup languages at this point in time is {md} {cite('''markdown''')}.
It is introduced by the designers of the language as follows:

`Markdown is a text-to-HTML conversion tool for web writers.`
`Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML).`

{md}'s goal is to be easy to write and read as a plain text document and as such is actually based on plain text emails.
Due to this, it attracts a lot of people's attention as it is very easy to create a new simple document, such as a short report.
It achieves this by introducing a small and simple syntax {cite('''mdsyntax''')}. The syntax they chose also feels very natural.
For example, to create a title you could underline it with \- or = and to create an enumeration, you can use \*'s instead of bullet points.

By using such a simple syntax compile times for the documents are very short and IDE support is wide.
Even without the help of an IDE, {md} is very readable as it was designed to be.
Another advantage of this simple syntax is that it almost entirely removes the possibility of syntax errors to occur.

Due to it's simple nature and limited syntax {md} can be easily translated into other formats such as PDF or HTML.
A tool to convert {md} to HTML is offered by the designers of the language itself, as stated above.
This further increases the appeal of the language, as it allows to very easily create elegant looking documents in a variety of formats.

As {md} files are just plain text files they are robust to file corruption and easy to recover from said corruption.
A corrupted byte would show easily and it would likely not destroy the layout of the document as there are so few reserved symbols being used in a {md} document.

Due to the fact that {md} uses plain text, it is cross-platform and because it has such a simple syntax, compilers are available for all major operating systems.
As a matter of fact, the Perl script offered by the {md} designers, is cross-platform.
{md} also natively allows for UTF-8 characters to be used in the text thus not requiring weird escape sequences to insert certain symbols.
A last advantage of plain text is that it is well suited for Version Control Systems (VCS) such as Git and Mercury.

To illustrate the simplicity of {md} an example document is shown below:
{{
    Image i = image("The document rendered as HTML by the official markdown conversion tool", '''document''');
    i.rightOf(new LstInputListing('''document.md'''));
}}



To allow for some customisability, {md} allows you to use inline HTML.
In case {md} does not support what you want to do, HTML is what you use.
Tables are not a part of default {md} (though there are variations that have syntax for them, like Github {md}), so an example of how to create one using HTML is shown below:
{{
    Image i = image("The table document rendered as HTML by the official markdown conversion tool", '''htmltable''');
    i.rightOf(new LstListing('''
Below you can find an HTML table
<table border="1">
    <tr>
        <td>
            Element 1
        </td>
        <td>
            Element 2
         </td>
     </tr>
</table>
    '''));
}}

### {lat}
// TODO: show some trees, that show structure
{lat} provides a, Turing complete, programming model and due to this allows for rich customisability.
It also provides a packaging system that allows for libraries, called packages, to be created using this programming model.
Over the course of the past 38 years (the initial TeX release was in 1978) a lot of packages have been created for all kinds of different functionality.
This is one of the reasons why {lat} is often used for long and complex documents such as books, articles, scientific papers and syllabi.

Like {md} lat uses a plain text format that is quite robust to file corruptions and is well suited for VCS.
It is however less robust against file corruption as the syntax is a lot more extensive and thus file corruption could lead to your document not compiling any more a lot easier.
It also doesn't use UTF-8 making it harder to type more exotic characters such as *Ã«*. Later iterations of TeX, such as XeTex and LuaTex do support UTF-8 though.

In {lat} the structure and the layout of your document are split by design. {lat} forces you to create a structured document by requiring you to use `sections, paragraphs,...`.
When using a WYSIWYG word processor for example, usually there is a way to structure your documents, using `styles, headers,...` but it is not forced on the user.
As a result, in {lat} consistency is enforced throughout the entire document without too much effort, while in aforementioned WYSIWYG word processors this is often forgotten and less convenient to use.
In a WYSIWG word processor, the user thus has to make sure his document is consistent.
Once documents get longer, this gets very hard to manage and to spot the inconsistencies.

Next to this customisability, {lat}'s typography is also very sophisticated.
It has support for kerning and ligatures and uses an advanced line-breaking algorithm, the Knuth-Plass line-breaking algorithm {cite('''texlba''')}.
The algorithm sees a paragraph as a whole instead of using a more naive approach and seeing each line individually.
Kerning places letters closer together or further away depending on character combinations.
A ligature is when multiple characters are joined into one glyph e.g fi vs. `fi`.

Another reason why {lat} is widely used due to its good scientific support.
{lat} and its libraries offer good support for mathematics as well as other scientific areas, e.g. you can create complex good looking graphs using {lat}.
Due to its high customisability, {lat} can handle about any kind of document you could think of, from sheet music and graphs, to letters and books.
It should be noted though that almost all of this functionality is offered through libraries such as PGF/TikZ {cite('''tikzman''')}.

{lat} also works together with BibTeX, a reference management software that is very robust and makes certain all of your references are consistent.
It also allows you to create the references outside of your main document, decreasing the amount of clutter in the document.
Whilst on the topic of including other files in your document, in {lat} you can split up your document into multiple smaller documents, allowing for easier management.
A common use of this function is to write every chapter, e.g. in a book, in a separate document and than all the chapters are imported into the main document.
This allows to easily remove or switch out different parts of a document.

Another very simple feature that {lat} has, is that is allows you to use vector graphics or PDF as images in your document.
This is something not possible in WYSIWIG word processors or lightweight markup languages such as {md}.

{lat} is free and open source, which is a huge point of attraction for the open source community.
As a result of this free and open source model, combined with its popularity and good scientific support, LaTeX has been integrated in many other applications.
A few examples are:
* MediaWiki {cite('''mwikilat''')}
* Stack Exchange
* JMathTex {cite('''jmathtex''')}
//TODO: add more examples

### {pan}
{pan} {cite('''pandoc''')} is a document converter, but in reality it can do much more than just convert a document from one format to another.
Notably, it allows you to write inline {lat} inside of a {md} document allowing for a much better experience than just using one of them.
However, {pan} does not really have a programming model, outside of the {lat} one, it works with so called filters.
When a document is issued for conversion, {pan} will transform the document into an Abstract Syntax Tree.
This AST can then be transformed using filters, the AST enters a filter, is transformed and is then past on to the next filter.
Filters can be written in a multitude of languages such as Haskell, Python, Perl,... and the filters to be used are passed as a command line argument to the conversion command.
// TODO: show an example

### Word processors
Modern word processors such as Microsoft Word and Pages are so called WYSIWYG editors.
As you immediately, without compiling, see what your document will look like it is a very popular tool.
The fact that you immediately see what you are writing also significantly decreases the complexity of the tool and it does not scare away less technical people the way {lat} does.
There is also no possibility to use commands as in {lat} or shorthand syntax as in {md}, instead buttons in the GUI offer all of the functionality.
Structure is not forced onto the user which offers less restrictions allowing the user to do what he wants.
It is also very easy to change a font type or change the font size of a certain part of the text.
Another feature that is loved in the WYSIWIG community is that you can easily add an image and drag and drop it around.

## Problem statement
We can see that these solutions all have there strong points but there are also quite a few gripes.
We will discuss the most common gripes for every solution underneath and afterwards introduce the problem statement.

### {md}
To achieve {md}'s simplicity, a hefty price has to be paid. All of the syntax elements have been hard coded into the language meaning there is no room for customisability.
The only way to customise {md} is by embedding inline HTML.
HTML allows users to create a solid structured model but it still does not allow for very much customisability.
While {md} is meant to be easily readable and writeable, HTML is not and using it thus decreases readability and cleanliness of your document significantly.
Once you use HTML in an {md} document, you also require a certain technical proficiency for the source document to be read or edited.
HTML also does away with the robustness of {md}'s plain text format, as having a tag being corrupted could lead to very big changes in the rendered file and might not even allow for compilation anymore.
HTML also reintroduces the possibility of syntax errors and thus slows down the document creation.
// TODO: example of layout destruction

The lack of customisability in {md} is further enforced due to the fact that it has no programming model.
It is one thing that the syntactic shorthands can not be reused, but there is also no other way, next to HTML to create an entirely new entity.

### {lat}
// TODO: easy syntax errors, not robust to errors, long repl cycles, unreadable error messages, mention LyX, customizing a document can be very hard
// TODO: requires some time to learn, especially to be able to customize/write packages, no UTF-8 without xe/luatex
Even though {lat} offers customisability through a programming model, it is not perfect.
The programming model is hard to use and is not easy to read.
Due to this programming model it also looks a lot more complex than {md}, scaring away a lot of potential users.

Having a cumbersome programming model, {lat} makes it easy to create syntax errors.
The robustness of a plain text document is also diminished, as your document will probably not even compile once an error occurs in one of the documents.
Something that is also very common in {lat} is that the shown error messages do not offer correct information and are often unclear.
See the excerpt below for an example of misleading error messages.
{{
LstListing a = appendContent(new LstListing('''
\documentclass{article}
\begin{document}
\begin{equation}
$a$
\end{equation}
\end{document}'''));
a.leftOf(new LstListing('''
line 4: Display math should end with $$.<to be read again>a $a
line 5: You can't use `\\\eqno' in math mode.\\\endequation ->\\\eqno\\\hbox {\\\@eqnnum }$$\\\@ignoretrue \\\end{equation}
line 6: Missing $ inserted.<inserted text>$ \\\end{equation}
'''));
}}
What it is actually trying to tell you is that you are not allowed to use \\\$ inside of an equation, but that is not clear from the error messages.

// TODO: Explain a little about macro expansion
The programming model used in {lat} does not use a static type system, which means that we have to compile the document to be able to see if we passed a wrong type to a macro at some point in the document.
It also does not work the way we are used to in imperative and functional languages. It does not have functions that receive parameters and that then call more functions.
Instead it has macro's and uses macroexpansion. As an example of how this translates into a real world example, a function the implementation of *foreach* in PGF/TikZ is shown below.

// TODO: reference src code
{
    new LstListing('''
\\\def\\\pgffor@foreach{%
\\\pgffor@atbeginforeach%
\\\let\\\pgffor@assign@before@code=\\\pgfutil@empty%
\\\let\\\pgffor@assign@after@code=\\\pgfutil@empty%
\\\let\\\pgffor@assign@once@code=\\\pgfutil@empty%
\\\let\\\pgffor@remember@code=\\\pgfutil@empty%
\\\let\\\pgffor@remember@once@code=\\\pgfutil@empty%
\\\pgffor@alphabeticsequencefalse%
\\\pgffor@contextfalse%
%
\\\let\\\pgffor@var=\\\pgfutil@empty
%
\\\pgffor@vars%
}
    ''');
}

Not only is this nearly unreadable and very complicated for such a common concept in programming, it also uses a ton of other functions defined in PGF/TikZ just to be able to define a foreach loop.

Luckily the application of a function is somewhat easier as shown below. The macro, called `loopfunction`, loops from 1 to a parameter \\\#1 and prints out a section in every iteration.
// TODO: does this work?
{
    new LstListing('''
\\\def\\\loopfunction#1{%
  \\\foreach \\\index in {1, ..., #1} {%
    \\\section*{Section \\\index}%
  }
}
    ''');
}

### {pan}
Transforming an AST afterwards is not always as easy as doing so inline, and it also hides what really happens to the document, which could cause confusion.

### Word processors
// TODO: consider templates
A first point to note is that the most popular word processors such as Microsoft Word and Pages are not free, but instead cost a significant amount.
There are free variants, such as LibreOffice and OpenOffice, but the compatibility between these word processors is not perfect.
The free alternatives usually also have less of a focus on the UI, making them look somewhat less sleek.

Another problem with word processors is that their format often changes over the years.
This means that your document might not show up the same, or at all, a few years later than when you wrote it.

// TODO: no programming model or something like VB
Even though some customisability is available, no programming model is available and real customisability is far to be found.
Due to their lack of a programming model, word processors do not allow for even the simplest of computations such as `The result is x + y`.

// TODO: add a label
It is also quite easy to create inconsistencies using word processors as noted above.
Next to creating inconsistencies, as structure is not enforced on you, small changes could have big side effects on the document.
// TODO: include image?
E.g. you placed an image exactly like you wanted, you then later on add a newline somewhere higher up, reflowing the text underneath it an shifting the precisely placed image around.
These changes are not always immediately clear, which further contributes to the creation of inconsistencies in the document.

Lastly, word processors often use a proprietary or complex format for there documents, which is not only bigger than a plain text document, but also a lot more prune to corruption.
A single bit flip could potentially irreversibly destroy your document.
These complex document formats are also hard to be used in combination with VCS.

## Proposed solution: Neio
To counter the problems occurring in the state of the art solutions, we bring forth a new markup language called `Neio` (read as neo).
To be able to solve some of the aforementioned problems and still make use of all of their advantages, the following goals were devised for the Neio markup language:
- User-friendliness: has to be easy to get started with the language
- Has to use a modern programming paradigm
- Has to be highly customisable

The first goal supplies us with a simple language that allows to very easily create simple documents.
The use of a modern programming paradigm allows us to customise the document and execute easy and complex computations easily in effect achieving the third goal.
### Target group

# Design of the Neio markup language
In the previous chapter, {intro.ref()}, the state of the art concerning document creation has been discussed and we notice that some improvement is certainly possible.
All of the document creation tools discussed above have their advantages and disadvantages. 
In this chapter we will present the Neio language and we will explain how our decisions were reached and how they were affected by the state of the art solutions.

## Neio document
To illustrate some of the basic concepts we will now present an example. The typical files that a user will write are called Neio documents.
Neio documents are heavily based on {md} as {md} is so easy to read and write, since this is what most of our consumers will be seeing, this was a very important property.
Since our consumers will mostly write Neio documents, we are also able to use the widespread knowledge of {md} to increase the size of our audience and allow users to instantly get started with the language.
The following example is one of the most basic documents you can write using Neio.
{
    new LstListing('''
[Document]

# Chapter 1
This is some text in the first Paragraph.
    ''');
}

// TODO: show actual output
Even if you are not familiar with {md} than you probably immediately know what this document represents.
There is however a very significant difference with {md}. In markdown the syntax is hard-coded into the language, a \\\# will always represent a chapter for example.
In Neio, on the other hand, the language has no knowledge whatsoever of what \\\# means.
In fact, it does not know what anything in a Neio document means.
It does not know about these things because everything is a method call, chained together to form an object model that represents the document.
The reason for doing so is simple, we want to be able to customise our documents!
For example, when you are creating a slide show you might not want \\\# to create a new chapter, instead it would be better and clearer if it would just create a new slide.

Knowing this we can now represent the document as a chain of method calls as follows:
{
    new LstListing('''
new Document()
    .#("Chapter 1")
    .text("This is some text in the first Paragraph");
    ''');
}

Now is also a good time to explain a small syntactical difference with {md}, which you might have already noticed.
Every Neio document has to begin with a so-called document class. This is a concept borrowed from {lat}, and just as in {lat} it tells us what kind of document the user is trying to build.
We say that a Neio document  has to start with a document class, but this is not completely correct.
You are allowed to add single- or multi-line Java style comments before the document, or anywhere else in the document for a matter of fact.
The following is thus also a valid document.
{
    new LstListing('''
// A single-line comment
[Document]
/*
 * Multi-line comments are also available!
 */
    ''');
}

To further understand this example we need to introduce the second kind of files available in the Neio markup language, Class files.

## Class files
Class files are very similar to class files in Java. They are the thriving force behind the Neio documents, they define all the object and methods that are used in a Neio document.
As means of an introduction we will have a look at the Document class that was used as a document class in the previous section.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Document.no''');
}

Except for some variations on the syntax, such as using `namespace` instead of `package`, and the lack of access level modifiers, this is valid Java code.
The access level modifiers are automatically set to `private` for members and `public` for methods.
Again, I stand corrected, this would be valid Java code if not for the \\\# method.
In Neio class files you are allowed to use symbols as a method name.
This is a feature that is necessary to allow a Neio document to be represented as a chain of method calls as otherwise you would have to actually write out a document as series of method calls.
This includes adding unnecessary symbols such as brackets to pass parameters, quotes to indicate strings and so on.
All the symbols you can use for method names can be found in . // TODO: reference whitelist

To keep the language simple and to maximize reusability (as well as making the parsing somewhat easier) some functionality from the Java language was dropped.
It is for example not possible to create anonymous classes as this goes against the concept of reusability.

## Language features
### Context types
As said before, everything is a method call, but to be able to just chain any method to any other method, regular methods do not suffice.
We want to be able to call methods of different class files whilst constructing our document, but we do not want to specify what object we're calling the method on.
This is something that should be clear from the current structure of the file.

To be able to call the right methods, we introduced ContextTypes. Any time an instance of an object is returned form such a method we wrap it into a ContextType, together with the object created in the previous method call.
This first object is the object that was returned from the most recent method call, we call it the actual type.
The second object is the object that was returned in the last but one method call, it is called the context type as it represents the context of the document at that point in time.
When we call a method on a ContextType, we first check if the actual type has the method we're trying to call.
If it does than we stop searching, if not we recursively check the context type.
// TODO: include figures

### Nested methods
Documents often have recursive elements such as sections or enumerations, as in Neio, everything is a method every one of these levels would have to be defined as a separate method.
This is of course very cumbersome and we would like to only define it once. This is why nested methods were invented.
A method can be annotated with a `nested` modifier which means that this method implicitly takes an extra argument, an `Integer` that reflects the depth of this recursive method.

### Surround methods
A method could also be annotated with a `surround` modifier. This means that the method name surrounds a piece of text, this can be used to for example create bold text by surrounding it with stars.

### Code blocks
#### Scoped code
#### Non scoped code
#### Inline code

## Considerations
### Static typing
### Security

## Reuse of current possibilities
### Binding to {lat}

# Supported document types and libraries
This chapter will go into some more details about what document types can be handled by Neio, and how to specifically build these kind of documents.
We will also discuss which libraries have been recreated in Neio to allow for a wide use of the language.

## Document types
### Report
### Letter
### Book
### Article
### Slides

## Libraries
### TikZ
### Beamer
### {lat} math and amsmath
### {lat} tables
### Lilypond

# Implementation
## Used libraries and frameworks
### ANTLR4
### Chameleon

## Compile flow
{
    Image compileFlow = image("Illustration of how a Neio document is compiled. Neio class files translate to Java classes, Neio script files to a Java file with a main function. This then gets output to Tex using Neio's standard library", '''CompileFlow''');
    return compileFlow;
}
In {compileFlow.ref()} the flow that a source document goes through before reaching a rendered state is depicted.

## Translation
### Escaping
### Fluent Interface
### Reflection
### Limitations
### Reasons for choosing Java
### Automatic Text conversion

## Outputting

# Future work
## Static typing of the language
## Package support
## Compiler improvement
### Correct stages
### Other front- and backends
## Tool improvement
### Syntax highlighting
### Auto completion

