[Thesis]

{
    addBibtex('''references''');
    String lat = '''LaTeX''';
    String md = '''Markdown''';
    String pan = '''Pandoc''';
}

# Introduction
{Chapter intro = (Chapter) parent()}
In this thesis we will be introducing a new markup language that tries to improve upon a few others, namely {lat} and {md}, whilst still holding on to their advantages.
Before we get into the details of this new language it is necessary to introduce some of the currently most used markup languages and word processors.
This introduction will provide the context from which the necessity of this thesis was sparked.

## State of the art
### {md}
One of the most popular markup languages at this point in time is {md} {cite('''markdown''')}.
It is introduced by the designers of the language as follows:

`Markdown is a text-to-HTML conversion tool for web writers.`
`Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML).`

{md}'s goal is to be easy to write and read as a plain text document and as such is actually based on plain text emails.
Due to this, it attracts a lot of people's attention as it is very easy to create a new simple document, such as a short report.
It achieves this by introducing a small and simple syntax {cite('''mdsyntax''')}. The syntax they chose also feels very natural.
For example, to create a title you could underline it with \- or \= to create an enumeration, you can use \*'s instead of bullet points.

By using such a simple syntax compile times for the documents are very short and IDE support is wide.
Even without the help of an IDE, {md} is very readable as it was designed to be.
Another advantage of this simple syntax is that it almost entirely removes the possibility of syntax errors to occur.

Due to it's simple nature and limited syntax {md} can be easily translated into other formats such as PDF or HTML.
A tool to convert {md} to HTML is offered by the designers of the language itself, as stated above.
This further increases the appeal of the language, as it allows to very easily create elegant looking documents in a variety of formats.

As {md} files are just plain text files they are robust to file corruption and easy to recover from said corruption.
A corrupted byte would show easily and it would likely not destroy the layout of the document as there are so few reserved symbols being used in a {md} document.

Due to the fact that {md} uses plain text, it is cross-platform and because it has such a simple syntax, compilers are available for all major operating systems.
As a matter of fact, the Perl script offered by the {md} designers, is cross-platform.
{md} also natively allows for UTF-8 characters to be used in the text thus not requiring weird escape sequences to insert certain symbols.
A last advantage of plain text is that it is well suited for Version Control Systems (VCS) such as Git and Mercury.

To illustrate the simplicity of {md} an example document is shown below:
{{
    Image i = image("The document rendered as HTML by the official markdown conversion tool", '''document''');
    i.rightOf(new LstInputListing('''document.md'''));
}}

To allow for some customisability, {md} allows you to use inline HTML.
In case {md} does not support what you want to do, HTML is what you use.
Tables are not a part of default {md} (though there are variations that have syntax for them, like Github {md}), so an example of how to create one using HTML is shown below:
{{
    Image i = image("The table document rendered as HTML by the official markdown conversion tool", '''htmltable''');
    i.rightOf(new LstListing('''
Below you can find an HTML table
<table border="1">
    <tr>
        <td>
            Element 1
        </td>
        <td>
            Element 2
         </td>
     </tr>
</table>
    '''));
}}

### {lat}
{Chapter latexGripes = (Chapter) parent()}
// TODO: show some trees, that show structure
{lat} provides a, Turing complete, programming model and due to this allows for rich customisability.
It also provides a packaging system that allows for libraries, called packages, to be created using this programming model.
Over the course of the past 38 years (the initial TeX release was in 1978) a lot of packages have been created for all kinds of different functionality.
This is one of the reasons why {lat} is often used for long and complex documents such as books, articles, scientific papers and syllabi.

Like {md} lat uses a plain text format that is quite robust to file corruptions and is well suited for VCS.
It is however less robust against file corruption as the syntax is a lot more extensive and thus file corruption could lead to your document not compiling any more a lot easier.
It also doesn't use UTF-8 making it harder to type more exotic characters such as *Ã«*. Later iterations of TeX, such as XeTex and LuaTex do support UTF-8 though.

In {lat} the structure and the layout of your document are split by design. {lat} forces you to create a structured document by requiring you to use `sections, paragraphs,...`.
When using a WYSIWYG word processor for example, usually there is a way to structure your documents, using `styles, headers,...` but it is not forced on the user.
As a result, in {lat} consistency is enforced throughout the entire document without too much effort, while in aforementioned WYSIWYG word processors this is often forgotten and less convenient to use.
In a WYSIWG word processor, the user thus has to make sure his document is consistent.
Once documents get longer, this gets very hard to manage and to spot the inconsistencies.

Next to this customisability, {lat}'s typography is also very sophisticated.
It has support for kerning and ligatures and uses an advanced line-breaking algorithm, the Knuth-Plass line-breaking algorithm {cite('''texlba''')}.
The algorithm sees a paragraph as a whole instead of using a more naive approach and seeing each line individually.
Kerning places letters closer together or further away depending on character combinations.
A ligature is when multiple characters are joined into one glyph e.g fi vs. `fi`.

Another reason why {lat} is widely used due to its good scientific support.
{lat} and its libraries offer good support for mathematics as well as other scientific areas, e.g. you can create complex good looking graphs using {lat}.
Due to its high customisability, {lat} can handle about any kind of document you could think of, from sheet music and graphs, to letters and books.
It should be noted though that almost all of this functionality is offered through libraries such as PGF/TikZ {cite('''tikzman''')}.

{lat} also works together with BibTeX, a reference management software that is very robust and makes certain all of your references are consistent.
It also allows you to create the references outside of your main document, decreasing the amount of clutter in the document.
Whilst on the topic of including other files in your document, in {lat} you can split up your document into multiple smaller documents, allowing for easier management.
A common use of this function is to write every chapter, e.g. in a book, in a separate document and than all the chapters are imported into the main document.
This allows to easily remove or switch out different parts of a document.

Another very simple feature that {lat} has, is that is allows you to use vector graphics or PDF as images in your document.
This is something not possible in WYSIWIG word processors or lightweight markup languages such as {md}.

{lat} is free and open source, which is a huge point of attraction for the open source community.
As a result of this free and open source model, combined with its popularity and good scientific support, LaTeX has been integrated in many other applications.
A few examples are:
* MediaWiki {cite('''mwikilat''')}
* Stack Exchange
* JMathTex {cite('''jmathtex''')}
//TODO: add more examples

### {pan}
{pan} {cite('''pandoc''')} is a document converter, but in reality it can do much more than just convert a document from one format to another.
Notably, it allows you to write inline {lat} inside of a {md} document allowing for a much better experience than just using one of them.
However, {pan} does not really have a programming model, outside of the {lat} one, it works with so called filters.
When a document is issued for conversion, {pan} will transform the document into an Abstract Syntax Tree.
This AST can then be transformed using filters, the AST enters a filter, is transformed and is then past on to the next filter.
Filters can be written in a multitude of languages such as Haskell, Python, Perl,... and the filters to be used are passed as a command line argument to the conversion command.
// TODO: show an example

### Word processors
Modern word processors such as Microsoft Word and Pages are so called WYSIWYG editors.
As you immediately, without compiling, see what your document will look like it is a very popular tool.
The fact that you immediately see what you are writing also significantly decreases the complexity of the tool and it does not scare away less technical people the way {lat} does.
There is also no possibility to use commands as in {lat} or shorthand syntax as in {md}, instead buttons in the GUI offer all of the functionality.
Structure is not forced onto the user which offers less restrictions allowing the user to do what he wants.
It is also very easy to change a font type or change the font size of a certain part of the text.
Another feature that is loved in the WYSIWIG community is that you can easily add an image and drag and drop it around.

## Problem statement
We can see that these solutions all have there strong points but there are also quite a few gripes.
We will discuss the most common gripes for every solution underneath and afterwards introduce the problem statement.

### {md}
To achieve {md}'s simplicity, a hefty price has to be paid. All of the syntax elements have been hard coded into the language meaning there is no room for customisability.
The only way to customise {md} is by embedding inline HTML.
HTML allows users to create a solid structured model but it still does not allow for very much customisability.
While {md} is meant to be easily readable and writeable, HTML is not and using it thus decreases readability and cleanliness of your document significantly.
Once you use HTML in an {md} document, you also require a certain technical proficiency for the source document to be read or edited.
HTML also does away with the robustness of {md}'s plain text format, as having a tag being corrupted could lead to very big changes in the rendered file and might not even allow for compilation anymore.
HTML also reintroduces the possibility of syntax errors and thus slows down the document creation.
// TODO: example of layout destruction

The lack of customisability in {md} is further enforced due to the fact that it has no programming model.
It is one thing that the syntactic shorthands can not be reused, but there is also no other way, next to HTML to create an entirely new entity.

### {lat}
// TODO: easy syntax errors, not robust to errors, long repl cycles, unreadable error messages, mention LyX, customizing a document can be very hard
// TODO: requires some time to learn, especially to be able to customize/write packages, no UTF-8 without xe/luatex
Even though {lat} offers customisability through a programming model, it is not perfect.
The programming model is hard to use and is not easy to read.
Due to this programming model it also looks a lot more complex than {md}, scaring away a lot of potential users.
There are a few ways to counter this complex look though, for one there is LyX. This is a GUI around {lat} offering some of the most common WYSIWG features, while still utilizing {lat}'s strength.
Even though the complexity is now hidden under a GUI, it is still there and error messages are as bad as they were before, as is discussed beneath.

Having a cumbersome programming model, {lat} makes it easy to create syntax errors.
The robustness of a plain text document is also diminished, as your document will probably not even compile once an error occurs in one of the documents.
Something that is also very common in {lat} is that the shown error messages do not offer correct information and are often unclear.
See the excerpt below for an example of misleading error messages.
{{
LstListing a = appendContent(new LstListing('''
\documentclass{article}
\begin{document}
\begin{equation}
$a$
\end{equation}
\end{document}'''));
a.leftOf(new LstListing('''
line 4: Display math should end with $$.<to be read again>a $a
line 5: You can't use `\eqno' in math mode.\endequation ->\eqno\hbox {\@eqnnum }$$\@ignoretrue \end{equation}
line 6: Missing $ inserted.<inserted text>$ \end{equation}
'''));
}}
What it is actually trying to tell you is that you are not allowed to use \$ inside of an equation, but that is not clear from the error messages.

// TODO: Explain a little about macro expansion
The programming model used in {lat} does not use a static type system, which means that we have to compile the document to be able to see if we passed a wrong type to a macro at some point in the document.
It also does not work the way we are used to in imperative and functional languages. It does not have functions that receive parameters and that then call more functions.
Instead it has macro's and uses macroexpansion. As an example of how this translates into a real world example, a function the implementation of *foreach* in PGF/TikZ is shown below.

// TODO: reference src code
{
    new LstListing('''
\def\pgffor@foreach{%
\pgffor@atbeginforeach%
\let\pgffor@assign@before@code=\pgfutil@empty%
\let\pgffor@assign@after@code=\pgfutil@empty%
\let\pgffor@assign@once@code=\pgfutil@empty%
\let\pgffor@remember@code=\pgfutil@empty%
\let\pgffor@remember@once@code=\pgfutil@empty%
\pgffor@alphabeticsequencefalse%
\pgffor@contextfalse%
%
\let\pgffor@var=\pgfutil@empty
%
\pgffor@vars%
}
    ''');
}

Not only is this nearly unreadable and very complicated for such a common concept in programming, it also uses a ton of other functions defined in PGF/TikZ just to be able to define a foreach loop.

Now we can include the `pgffor` package and apply this function. Luckily it is somewhat easier to use, than to create, as is shown below.
{
    Image loopFunction = new LstListing('''
\def\loopfunction#1{
  \ foreach \index in {1, ..., #1} {
    \section*{Section \index}
  }
}
    ''').leftOf(image("The document produced from calling `loopfunction` with parameter `1`", '''loopfunction''')).scale(30);
}
The macro, called `loopfunction`, loops from 1 to a parameter \#1 and prints out a section in every iteration.
Calling it using the following code `\\loopfunction{5}` results into the document shown in {loopFunction.ref()}.

### {pan}
Transforming an AST afterwards is not always as easy as doing so inline, and it also hides what really happens to the document, which could cause confusion.

### Word processors
// TODO: consider templates
A first point to note is that the most popular word processors such as Microsoft Word and Pages are not free, but instead cost a significant amount.
There are free variants, such as LibreOffice and OpenOffice, but the compatibility between these word processors is not perfect.
The free alternatives usually also have less of a focus on the UI, making them look somewhat less sleek.

Another problem with word processors is that their format often changes over the years.
This means that your document might not show up the same, or at all, a few years after you wrote it.

// TODO: no programming model or something like VB
Even though some customisability is available, no programming model is available and real customisability is far to be found. You are stuck to what the developers of editor defined and implemented.
There is no way to go beyond what the designers specified. Due to this it is not always possible to do exactly what you want either.
When you have a few elements in your document and you try to align a new element with it, it will snap to all sorts of guidelines, but chances are you want to place it in between all of the guidelines,
which is not possible at that moment.
Due to their lack of a programming model, word processors do not allow for even the simplest of computations such as `The result is x + y`.

It is also quite easy to create inconsistencies using word processors as noted above in {latexGripes.ref()}.
Next to creating inconsistencies, as structure is not enforced on you, small changes could have big side effects on the document.
// TODO: include image?
E.g. you placed an image exactly like you wanted, you then later on add a newline somewhere higher up, reflowing the text underneath it an shifting the precisely placed image around.
These changes are not always immediately clear, which further contributes to the creation of inconsistencies in the document.

Lastly, word processors often use a proprietary or complex format for there documents, which is not only bigger than a plain text document, but also a lot more prune to corruption.
A single bit flip could potentially irreversibly destroy your document.
As complex or binary document formats are used, it is hard to use WYSIWIG editors in combination with VCS.
This makes it inconvenient to track changes made to the document and go back to an earlier version of the document.
It also makes it harder to work on a document as a team, you might be making changes at the same time as someone else, but you have no way of automatically merging both documents 
creating a possibility of data to get lost.

## Proposed solution: Neio
To counter the problems occurring in the state of the art solutions, we bring forth a new markup language called `Neio` (read as neo).
To be able to solve some of the aforementioned problems and still make use of all of their advantages, the following goals were devised for the Neio markup language:
- User-friendliness: has to be easy to get started with the language
- Has to use a modern programming paradigm
- Has to be highly customisable

The first goal supplies us with a simple language that allows to very easily create simple documents.
The use of a modern programming paradigm allows us to customise the document and execute easy and complex computations easily in effect achieving the third goal.

To achieve this we chose to use a syntax like {md} to write our documents in as it is the easiest to read and write.
For the programming paradigm we chose for something much like Java as Java is very well known, and working with macro expansion's or filters is not ideal.
Lastly, we choose to translate to LaTeX as it has been successively used for decades and has proven by now that it can deliver very clean looking documents.
Later on more back ends, such as HTML, could be implemented, but that is outside of scope of this thesis.

### Target group
Neio targets anyone that is currently using {md} but just wants to be able to customise their document a bit more.
// TODO: label
As we will see later, in Neio it is easy to for example create two images and put them next to each other, something that is not possible in markdown.

It can also be used by people without technical expertise if templates are provided.
E.g. given a template for a letter, even a non-technical person is able to quickly write down the contents of the letter and fill in the template variables.

Neio also target package developers and programmers in general as it offers a modern programming model that is a lot well known and much easier than TeX's system.
This includes full-time developers as well as students or professors.

# Design of the Neio markup language
In the previous chapter, {intro.ref()}, the state of the art concerning document creation has been discussed and we notice that some improvement is certainly possible.
All of the document creation tools discussed above have their advantages and disadvantages. 
In this chapter we will present the Neio language and we will explain how our decisions were reached and how they were affected by the state of the art solutions.

## Neio document
To illustrate some of the basic concepts we will now present an example. The typical files that a user will write are called Neio documents.
Neio documents are heavily based on {md} as {md} is so easy to read and write.
Since this document is what most of our consumers will be seeing, this was a very important property.
Since our consumers will mostly write Neio documents, we are also able to use the widespread knowledge of {md} to increase the size of our audience and allow users to instantly transition to Neio.
The following example is one of the most basic documents you can write using Neio.
{
    String simpleDocument = '''
[Document]

# Chapter 1
This is some text in the first Paragraph.
''';
    Image i = new LstListing(simpleDocument).leftOf(image("The rendered document", '''simpleDocument'''));
    
}

Even if you are not familiar with {md}, you can probably immediately tell what this document represents.
There is however a very significant difference with {md}. In markdown the syntax is hard-coded into the language, a \# will always represent a chapter for example.
In Neio, on the other hand, the language has no knowledge whatsoever of what \# means.
In fact, it does not know what anything in a Neio document means.
It does not know about these things because everything is a method call, chained together to form an object model that represents the document.
The reason for doing so is simple, we want to be able to customise our documents!
For example, when you are creating a slide show you might not want \# to create a new chapter, instead it would be better and clearer if it would just create a new slide.

Knowing this we can now represent the document as a chain of method calls as follows:
{
    new LstListing('''
new Document()
    .#("Chapter 1")
    .text("This is some text in the first Paragraph");
    ''');
}

For this to work of course, every one of these method calls has to return an object.
In fact, every one of these methods will return an object that is a subtype of the `Content` class, anything in a Neio document that can be shown is a subtype of `Content`.
The `Content` class is the base class in Neio documents, like `Object` is the base class in Java.

Now is also a good time to explain a small syntactical difference with {md}, which you might have already noticed.
Every Neio document has to begin with a so-called document class. This is a concept borrowed from {lat}, and just as in {lat} it tells us what kind of document the user is trying to build.
We say that a Neio document  has to start with a document class, but this is not completely correct.
You are allowed to add single- or multi-line Java style comments before the document, or anywhere else in the document for a matter of fact.
The following is thus also a valid document.
{
    new LstListing('''
// A single-line comment
[Document]
/*
 * Multi-line comments are also available!
 */
    ''');
}

To further understand this example we need to introduce the second kind of files available in the Neio markup language, Class files.

## Class files
Class files are very similar to class files in Java. They are the thriving force behind the Neio documents, they define all the object and methods that are used in a Neio document.
As means of an introduction we will have a look at the Document class that was used as a document class in the previous section.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Document.no''');
}

Except for some variations on the syntax, such as using `namespace` instead of `package`, and the lack of access level modifiers, this is valid Java code.
The access level modifiers are automatically set to `private` for members and `public` for methods.
They do not have to be written explicitly as the default value is usually what the developer wants and it makes the class file just a little clearer and more concise.

Again though, I stand corrected, this would be valid Java code if not for the \# method.
In Neio class files, you are allowed to use symbols as a method name.
This is a feature that is necessary to allow a Neio document to be represented as a chain of method calls as otherwise you would have to actually write out a document as series of method calls,
or you would not be able to use symbols as syntactic shorthand.
All the symbols you can use for method names at this time are `\#, \-, \*, \_, \$, \|, \=, \^`, the backtick and the newline.
The newline character is recognised by the following regex `\\n\\r?`.

To keep the language simple and to maximize reusability (as well as making the parsing somewhat easier) some functionality from the Java language was dropped.
It is for example not possible to create anonymous classes as this goes against the concept of reusability.
It is also not possible to create multiple classes in a single file.

## Newlines
{Chapter newlines = (Chapter) parent()}
Neio is newline sensitive, in the sense that newlines too are methods.
The superclass `TextContainer` of `Document` and `Chapter` defines the following method.
{
    new LstListing('''
/**
 * Handles newlines
 *
 * @return returns a new ContainerNLHandler
 */
ContainerNLHandler newline() {
    return new ContainerNLHandler(this);
}''');
}

The `ContainerNLHandler` will then further handle the flow of the document.
The code for `ContainerNLHandler` and `NLHandler` are added below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/ContainerNLHandler.no''');
}

{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/NLHandler.no''');
}

Our earlier example now translates to the following:
{
    new LstListing('''
new Document()
    .newline()
    .newline()
    .#("Chapter 1")
    .newline()
    .text("This is some text in the first Paragraph");
    ''');
}

We needed to do this because a newline in a plain text document has meaning, depending on the context it can mean something else entirely.
For example, a single newline in a paragraph should append the next sentence to the paragraph.
But on the other hand when we separate two text blocks with an empty line (thus two newlines), the blocks of text are seen as two different paragraphs.

It should also be noted that any text written in a Neio document gets translated to the `text` call as seen in the example above.
An implementation of the text method is seen `NLHandler`.
The reason for this will become clear later on.

We will see more advanced examples using newline in Chapter 3 that will further expose its benefits.
To avoid clutter, the `newline` method will not be shown in the further examples unless it is needed to understand the example.

## Language features
### Context types
As said before, everything is a method call, but to be able to just chain any method to any other method, regular methods do not suffice.
We want to be able to call methods of different class files whilst constructing our document, but we do not want to specify what object we're calling the method on.
This is something that should be clear from the current structure of the file, a previously created object should have a method with the correct signature.

To be able to call the right methods, we need to introduce something called ContextTypes.
A ContextType combines an object, the actual type, with its context.
We will illustrate this using an example.

{
    LstListing context = new LstListing('''\n[Document]\n''');
    return context;
}

As we saw before this translates to the new call `new Document()`.
This is actually a ContextType of the newly created `Document` and `null` as there is nothing else yet.
We'll call this ContextType `ct1`.

Lets add a chapter to it, when there are two elements, there should be some kind of context.
{
    Text ct2Caption = "In the image above we find ourselves at the *X*. We follow the red arrow upwards and find ourselves in Document. As Document contains the \# method, we call \# on Document and a Chapter is added to the Document , as represented by the green arrow.";
    LstListing context2 = image(ct2Caption, '''ct1''').rightOf(context.append('''\n#Chapter 1'''));
}

By adding this call our document translates to the following`new Document().\#("Chapter 1")`.
The addition of a second element allows us to see a ContextType in action.

To know where to find the \# method, we will recursively iterate over our context.
First we check the actual type of `ct1`, if we could not find the method there, we recursively proceed to check the context of `ct1`.
As you can see above in the source code of `Document`, there is indeed a method \# in there, so there is no need to look any further.
The current document translates to ContextType `ct2`, which contains the newly created Chapter and has `ct1` as context.

We continue by adding one more Chapter.
{
    LstListing context3 = image('''ct2''').rightOf(context2.append('''\n#Chapter 2'''));
}

Now when we look for the \# method in `ct2` we first have to check Chapter, but Chapter does not have this method.
We thus recursively check the context of `ct2`, which is `ct1`.
`ct1`'s actual type is a Document, of which we know that it has a \# method.
As we have found the method we were looking for, \# will be called on the Document in `ct1`.
The ContextType that is created for this call is `ct3` that has the newly created Chapter as the actual type, but that has *ct1* as context.
This is because we have had to skip over `Chapter 1`, which shows us that `ct2` is not useful anymore for the continued creation of the document.

Lastly we add a paragraph to the document.
{
    LstListing context4 = image('''ct3''').rightOf(context3.append('''\nThis is a paragraph.'''));
}

We check the actual type of `ct3` and immediately have a matching method, we thus call the method on `Chapter 2`.
The newly created ContextType `ct4`, contains the `Paragraph` as actual type and `ct3` as context.

The following structure is what we are left with.
{ image("The final structure built in the example", '''ct4''').scale(100) }

### Nested methods
Documents often have recursive elements such as sections or enumerations, as in Neio, everything is a method every one of these levels would have to be defined as a separate method.
That means creating a method for \#, \#\#, \#\#\#,... .
This is of course very cumbersome, even impossible at times, and we would like to only define it once as the behaviour should be mostly the same no matter how many symbols we use.
Usually only one property, such as font size, is effected by the number of symbols used in such a method call.
This is why nested methods were invented.
A method can be annotated with a `nested` modifier which means that this method implicitly takes an extra argument, an `Integer` that reflects the depth of this recursive method.
The depth of this recursive method is just the number of times the symbol has been used.
If we have a look at the `Chapter` class, we see that it has a nested method \#.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Chapter.no''');
}

If we would now call `chapter.\#\#("Chapter 1.1")` for example, it would translate to the following call: `chapter.\#("Chapter 1.1", 2)`.

An important thing to note is, that the regex matching a nested function, is `..+` where `.` is the symbol that is being used as a method name.
This means that the method that contains a single symbol, the method that defines the first level e.g. `\#(String name)`, should be defined elsewhere. This has been done because the first level is usually special.
In case of an Enumerate for example, when we create the first EnumerateItem, not only an EnumerateItem but also an Enumerate has to be added.
Usually the object created by this method should also be added in a different place than the other objects.
Let us take the following example:

{
    new LstListing('''
[Document]
# Chapter 1
## Chapter 1.1
# Chapter 2
    ''');
}

{
    Image nestedCorrect = image("The correct ContextType representation", '''NestedCorrect''').floating();
    Image nestedWrong = image("The wrong ContextType representation", '''NestedWrong''').floating();
}

We would want *Chapter 1* and *Chapter 2* to be children of Document, while *Chapter 1.1* should be a child of *Chapter 1*. The ContextType representation of the document is shown in {nestedCorrect.ref()}.
If we now say that the nested modifier works on any level, including the first level, then the aforementioned structure would still be achieved, *but* the ContextType representation would be different.
The ContextType representation of this document would be as shown in {nestedWrong.ref()}.
This is because `\# Chapter 2` is now a method call on `ct1` instead of on `ct0` as the `nested Chapter \#(String name, Integer level)` method in Chapter would be the function that resulted from our lookup.

### Surround methods
A method could also be annotated with a `surround` modifier. This means that the method name surrounds a piece of text, this can be used to for example create bold text by surrounding it with stars.
This is needed to be able to easily annotate text and it also looks very natural.

Examples of surround methods are the ones available in Text.no.
{
    new LstInputListing('''../../examples/0.8/lib/neio/lang/Text.no''');
}

The text `This is \*bold\* text` will then be transformed into the following chain `text("This is ").text(\*("bold")).text(" text")`.

### Code blocks
We've seen that we can use code in Neio class files and customise our document this way. But this doesn't allow us to do everything we want to.
We don't want to create a new document class every time we want to do something special. It's also not possible to add anything to a document class that does not exist.
Sometimes we might just want to change a property of some content, which is not possible as of yet.
For this reason, it is possible to add code blocks in a Neio document. The three different kinds of code blocks are explained below.
To avoid confusion, when you are writing text into a Neio document, we say that we are in Text mode.
While when we are writing code in a Neio document, we say that we are in Code mode.

#### Non-scoped code
Now let us say that we want to create a `Document` that uses a special type of content that we have created.
For example, we like Fibonacci so much, that we have created a special `Enumerate` that is numbered according to the Fibonacci sequence.
The code for this new `Enumerate`, `FibEnumerate` is shown below.
We also show the code for the `EnumerateItem` that is used in `FibEnumerate`, `FibItem`.
{
    new LstInputListing('''../../examples/0.8/lib/neio/fib/FibEnumerate.no''');
}

{
    new LstInputListing('''../../examples/0.8/lib/neio/fib/FibItem.no''');
}

The only real thing that changed in this code, compared to their super classes `Enumerate` and `EnumerateItem`, is the code to translate the object, given in the `toTex()` method.
There is however another odd line present in `FibEnumerate`'s constructor.
It concerns the following line:
{
    new LstListing('''
addClassMapping(EnumerateItem.class, FibItem.class);
    ''');
}

For now, it is enough simply to know that this acts mostly as a factory.
For this example it means that if `FibEnumerate` or one of it's children \(`FibItem`'s for example\) were to create an instance of the class `EnumerateItem`, that it will actually create a `FibItem`.
The reason we say it, acts as a factory, is because we're asking for a new instance of some object to be created and what we receive is a new instance of that specific class, or one of its subclasses.
How this works will be explained further on, in Chapter 4.
The bottom line is that this line of code allows us to reuse the `\-` method that has been defined in `Enumerate`, to create `FibItem`'s instead of having to redefine this method simply to create an instance of a subclass.
It also makes sure that we do not have to write a new factory every time we want to replace a general class by a more specific subclass, as would otherwise have been needed here.

Now to be able to get this `FibEnumerate` into a document all we have to do is open a code block and create a new `FibEnumerate`.
A non-scoped code block is represented as a pair of `\{\}`, where the `\{` is at the start of a line and the `\}` is followed by a newline.
The `\{` and `\}` can not appear on the same line. The reason for this will become clear further on.
Also note that a semicolon at the end of the last statement is optional, this is mostly useful in inline code blocks as we will see further on, but even in this case, it makes the document just a little bit easier and less prune to syntax errors.

{{
    image("The rendered Fibonacci document", '''fibDocument''').scale(25)
    .rightOf(new LstInputListing('''../../examples/0.8/input/testInput/fibDocument/fibDocument.no'''));
}}

The example above shows us that this works, but how exactly does this work, you might ask.
The reason that this works is because the new object is added to the current document and the following `\-` calls will thus be called on this object.
An object can only be added in this way through the last statement in a non-scoped code block and the object will only be added if it is a subtype of `Content`.
If the last statement does not return an object (a method call with a void return type or an assignment), nothing will be added.

To further explain this, and to explain how we could possibly call functions on an object we need to introduce a new concept called `this`.

#### This
{Chapter thisCode = (Chapter) parent()}
A Neio document has a concept of `this` like many programming languages do.
`this` will always refer to the last element that was created in Text mode.
But if that was the only way to interact with `this` we would not be able to call any methods (as we have nothing to call objects on) and we would not be able to add, modify or remove anything to/in the document either.
To show how exactly this works we will take a look at the translated form of the previous example.
{
    new LstListing('''
        new Document();

        FibEnumerate $var0 = new FibEnumerate()
        this.appendContent($var0);

        this.-(new neio.lang.Text(Item 1))
            .-(new neio.lang.Text(Item 2))
            .-(new neio.lang.Text(Item 3))
            ...
    ''')
}

We see that a separate statement was created for everything above our code block and that the code in our code block was than directly included into the code.
The last statement gets assigned to a variable and `appendContent` is called on `this`.
This is always what will happen when you use a non-scoped code block, this means that the compiler knows about the `appendContent` method.
Another example to further illustrate the use of non-scoped code blocks and `this` will be shown later on.
After appending the content, a new statement is started, containing our well known chain of method calls, but the first method is called upon `this`.

In the next stage of translation, variables will be assigned to the objects and this will be filled in with the last object created in Text mode, or the `Content` returned in a non-scoped code block.
The next step of translation is shown below.
{
    new LstListing('''
        Document $var0 = new Document();

        FibEnumerate $var1 = new FibEnumerate();
        FibEnumerate $var2 = $var0.appendContent($var1);

        $var2.-(new neio.lang.Text(Item 1))
            .-(new neio.lang.Text(Item 2))
            .-(new neio.lang.Text(Item 3))
            ...
    ''')
}

To show how code blocks work in combination with this, we will show another example.
{
    new LstListing('''
[Document]

This is the first paragraph
{
    Chapter c1 = #("Chapter 2");
    c1.*(new Text(c1.title()));
}

This is a paragraph
    ''');
}

Now to explain the example, in the example a `Document` is created and a `Paragraph` is added to it in Text mode.
Then in Code mode we create a new, `Chapter`, called `Chapter 1` using the `\#` method.
We then create a new `Enumerate` using the `\*` method and finally we add a `Paragraph` in Text mode.

The translated version of this example is shown below:
{
    new LstListing('''
new Document().newline().newline().text("This is the first paragraph").newline();

Chapter c1 = this.#("Chapter 1");
$var0 = c1.*(new Text(c1.title));

this.newline().newline().text("This is a paragraph");
    ''')
}

In further translation the first `this` will result into the `Document` while the second this will be `c1`. The reason that the first `this` will be the `Document` instead of `Paragraph`, is because of ContextType's.
`Paragraph` and `ContainerNLHandler` do not have a `\#` method', but `Document` does as is shown in the following UML (only public members are shown to prevent clutter).
{
    List<String> show = new ArrayList<String>();
    show.add('''neio.stdlib.Paragraph''');
    show.add('''neio.stdlib.ContainerNLHandler''');
    show.add('''neio.stdlib.Document''');
    new Uml('''./project.xml''', '''neio''').show(show);
}

A last point to note is that since your code is directly inserted into the translation, all the variables you have defined will be available from there on, and will take up their space in the current namespace.
This means that you can use your variables in other code blocks, but also means that generic identifiers like `i` should be avoided as you might want to be able to use this identifier again later on.

#### Scoped code
If all you want to do, is execute some arbitrary code without corrupting your namespace, a block of scoped code is the way to go.
The use of a block of scoped code is illustrated below.
{
    new LstListing('''
[Document]
# Chapter 1
{{
List<String> l = new ArrayList<String>();
l.add("upquote");
l.add("pdfpages");
l.add("url");
for (int i = 0; i < l.size(); i = i + 1) {
    addPackage(l.get(i));
}
}}
    ''');
}

In this example a `Document` is created but to be able to use it for our needs, we need a few more packages that are not included by default in `Document`.
We also do not want to think of very descriptive identifiers for our variables as it's just a simple operation, the name `l`should suffice.
Normally these variables would be defined in a short function and we would thus not have to worry about shadowing or overriding this name.
But as we saw in {thisCode.ref()}, our code is just inserted straight into the final document.
The difference is that a block of scoped block is inserted into its own scope. It also does not automatically add anything to the document like
non-scoped code does.
The previous example is translated to the following Java.
{
    new LstListing('''
Document $var0 = new Document();
ContainerNLHandler $var1 = $var0.newline();
Chapter $var2 = $var0.hash(new neio.lang.Text("Chapter 1"));
ContainerNLHandler $var3 = $var2.newline();
{
    List<String> l = new ArrayList<String>();
    l.add("upquote");
    l.add("pdfpages");
    l.add("pdfpages");
    for (int i = 0; i < l.size(); i = i + 1) {
        $var0.addPackage(l.get(i));
    }
}
    ''');
}

Another good reason for wanting to use scoped code, is when you only want to call a function that already adds an object to the `Document`.
Using non-scoped code, this object would be added to the `Document` again through `appendContent` as seen in {thisCode.ref()}.
An example is shown below.
{
    new LstListing('''
[Document]

{{
    image("image1")
}}
    ''');
}

This code creates an `Image`, but also adds it to the `Document`, as we don't want to add it twice, or invent an identifier for it, we use non-scoped code.
The code for the image function is shown below.
{
    new LstInputListing(53, 75, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''')
}

#### Inline code
Inline code is the last type of code blocks and is very like non-scoped code.
The difference is that it only allows one statement, and the opening and closing brackets should be placed on the same line.
As the name implies, this is code that is meant to be used inline. A few examples of this are shown below.
{{
    image("The rendered form of the example to the left", '''inlineCode''')
    .rightOf(new LstListing('''
[Document]

# Chapter 1
I created a document that only contained one chapter.
{
    Chapter c1 = nearestAncestor(Chapter.class);
    Integer printing = 1;
    Integer driving = 2;
    Integer timeWasted = 14;
}

It's called { c1.title() } and it cost me { printing + driving + timeWasted }!
    '''))
}}

In the example we get the first `Chapter` structurally above us, define some integers, and then later on we get the title of this chapter and do a calculation with our integers.
The result of this is returned and passed to the `text` method, as would normally happen with a piece of text.
Note that whatever comes out of the inline code block is first transformed into a String using the toString\(\) method.

The paragraph thus translates into the following chain.

`this.text("It's called ").text(c1.title().toString()).text(" and it cost me ").text("" + (printing + driving + timeWasted)).text("!");`

### Text
Something that has not been noted yet, is that most of the time, we don't actually use Java String's.
What is used most of the time is Neio Text. Neio Text (in Code mode, not in class files) is created like Java String's, by enclosing some text with a pair of doubles quotes \(`\"`\).
A Java String is still sometimes needed and can be created using a pair of triple, single-quotes \(`\'\'\'`\).
The difference is that Neio text can contain anything you would type in Text mode, which includes code blocks, you can thus effectively endlessly nest Text and Code mode.
The reason we use Neio text for most things instead of Java String's \(just have a look at a few of the methods in the UML shown below\), is because Neio text can be marked up, by using surround methods for example.
{
    List<String> showTC = new ArrayList<String>();
    showTC.add('''neio.stdlib.TextContainer''');
    new Uml('''./project.xml''', '''neio''').show(showTC).scale(100);
}

We could for example create a bold Chapter using the following code `new Chapter\(\*Bold chapter\*\)`.

## Considerations
{Chapter considerations = (Chapter) parent()}
Whilst constructing the language a few other things were considered but not implemented, they will be discussed below.
### Static typing
### Security
### Moving content
When we assign content to a variable, and try to use it later on with small changes, it is possible that the content moves or that both the original as the new content are changed.
The language does not enforce every placed content to be static and in turn this is the responsibility of the library developer and the user of those libraries.
### Use

# Supported document types and libraries
This chapter will go into some more details about what document types can be handled by Neio, and how to specifically build these kind of documents.
We will also discuss which libraries have been recreated in Neio to allow for a wide use of the language.

## Document types
### Report
### Letter
### Book
A prime subject of writing a book is this document itself. The entirety of this book has been created using Neio script.
//TODO add url
### Article
### Slides
### BibTeX
It is important to note that our BibTeX implementation is just a binding to LaTeX and does not really allow for any customisation.
We chose to do it this way, to illustrate that binding to LaTeX is not very difficult, and because we would have to create an entire parser for BibTeX to be able to create the object structure needed to have full control over BibTeX.
As the BibTeX format is quite complicated we felt that our time was better spent elsewhere.

## Libraries
### TikZ
### Beamer
### {lat} math and amsmath
### {lat} tables
### MetaUML
### Chemfig
### Lilypond

## Reuse of current possibilities
### Binding to {lat}

# Implementation
## Used libraries and frameworks
### ANTLR4
### Chameleon and Jnome
## Limitations
### Windows
Executing commands using the Java Process class came with some not immediately visible issues.
When developing on Linux, executing shell commands from Java worked perfectly fine and gave no problems whatsoever.
However, on Windows some of the processes would hang, some would always hang, some would hang only once in a while.
The reason for this is that Windows offers only a limited buffer size for the input and output streams of a process, the program deadlocks if the input is not written or read.
After closer inspection of the Javadoc {cite('''javaprocess''')} this became apparent but due to the API for the Process class being so simple, it was a surprise nevertheless.
The fact that we have to worry about different platforms on a cross-platform language as Java is also something that is not too common.

### Java

## Compile flow
{
    Image compileFlow = image("Illustration of how a Neio document is compiled. Neio class files translate to Java classes, Neio script files to a Java file with a main function. This then gets output to Tex using Neio's standard library", '''CompileFlow''');
    return compileFlow;
}
In {compileFlow.ref()} the flow that a source document goes through before reaching a rendered state is depicted.

## Translation
### Reasons for choosing Java
### Escaping
### Fluent Interface
### Reflection
### Automatic Text conversion

## Outputting

# Future work
As mentioned before in {considerations.ref()} there are still a few things that could be done in the future.
There are however a lot more things that could be done and we will discuss them in the rest of this chapter.
## Automatic StringBuilder
## Automatic return of the object itself
## Package support
## Implementation of packages
## Using Java syntax
## Reference to undefined Content
## Compiler improvement
### Correct stages
### Other front- and backends
## Tool improvement
### Syntax highlighting
### Auto completion
### IDE with preview

