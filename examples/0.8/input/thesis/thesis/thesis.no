[Thesis]
{
    preface.createDocument((Document) parent());
    permission.createDocument((Document) parent());
    overview.createDocument((Document) parent());
    addBibtex('''references''');
    String lat = '''LaTeX''';
    String md = '''Markdown''';
    String pan = '''Pandoc''';
    mainMatter();
}

# Introduction
{Chapter intro = (Chapter) parent()}
In this thesis we introduce a new markup language that improves upon a few others, namely {lat} and {md}, whilst still holding on to their advantages.
Before we get into the details of this new language it is necessary to introduce some of the most used markup languages and word processors.

## State-of-the-art
Before we discuss the state-of-the-art we first discuss the difference between saving a document as plain text or in a binary format.

{md}, {lat} and {pan} use a plain text format that is quite robust to file corruptions and is well suited for Version Control Systems (VCS) such as Git and Mercury.
It is robust in the sense that a if a single bit of the document gets flipped, the document is not irreversibly destroyed.

When the syntax is more extensive, the chances to create a problem upon compilation increase.
This is both good and bad, if a part of important syntax got corrupted, the compiler will tell you and you will know that the document has to be fixed, otherwise this might have been missed.
However corruption of such syntax can prevent the document from successfully compiling.
In any case, the document is not irreversibly destroyed.

This is possible however when using the binary format, like the ones used by default in a What You See Is What You Get (WYSIWYG) editor.
As a matter of proof, we created a Word document and flipped one bit (an `E` was changed to a `D` at a random place).
We then tried to open the document and received the following sequence of errors and were unable to retrieve the contents of the file.
{
    Image wordCorr = image("The detection of an error", '''wordCorruption''')
}
{{
    wordCorr.leftOf(new Image("The warning before trying to repair the error", '''wordCorruption2'''));
    image("The inability to repair the error", '''wordCorruption3''').scale(80);
}}

It is to be noted that the errors depend on what exactly was corrupted, in some cases the corruption can be automatically repaired.

### Word processors
{Chapter goodWord = (Chapter) parent()}
The best known solution for creating documents, are so called WYSIWYG editors, examples include 'Microsoft Word' and 'Pages'.
They are called as such because you immediately, without compiling, see what your document will look like.
Because of this, the complexity of the tool is significantly decreased allowing anyone to use the tool.
It is less complex because you do not have to type in commands and wait for a preview to change.
Instead you select the property from a drop-down list or click a button and the document is updated instantly.
The GUI essentially hides the complexity.

A WYSIWYG editor gives the author freedom, for example it is very easy to change a font or change the font size of a certain part of the text
and you can easily add an image and drag-and-drop it around.

A lot of these editors are grouped into packets, such as Office or iWork.
Using one of these packets, it is also easy to insert slides or tables.
These will then be editable with the specialized program for it (like Excel), but you will not have to leave the document.
In the example below an Excel chart has been inserted into a Word document.
{
    image("An Excel chart in a Word document", '''excelInWord''')
}

Collaboration is also made easy by using online versions of these solutions, such as 'Microsoft Word Online' or 'Google Docs'.
These make documents cross-platform and allow multiple people to work on them at the same time.
It is also possible to add comments or suggestions on (online) documents.
These changes can then be resolved in just one click by an authorized editor.
// TODO: auto-save?

Some documents are however more complex and have need for a more powerful tool such as {lat}.

### {lat}
{Chapter latexAdv = (Chapter) parent()}
TeX provides rich customisability through its Turing complete programming model.
The model is different from modern programming models, it does not use regular variable or functions, instead it uses macros.
A macro starts with a `\\` character, followed by a name and optionally followed by parameters.
To show how these work, we show the process involved in processing some input that includes a macro.

In TeX, every character and macro in the input is a token, `a` is a token but `\\macro` is also a token.
The input is transformed into a list of tokens and is then processed token after token.
When a macro is encountered, it is expanded.

Expansion removes the current token from the list and adds every expandable item in its body to the token list recursively.
This is best shown using an example.

We define two macros using `\\def` and call the `\\b` macro.
{
    new LstListing('''
\def\{This is \a\}
\def\a\{a\}
\b ''')
}

The output is `This is a`.
The step by step expansion works as follows.
* TeX encounters the token `\\b` without arguments and expands it.
* `\\b` is removed from the token list and `This is \\\u0061` is added to it.
* `This is ` is read and `\\a` is encountered, `\\a` gets expanded.
* `\\a` is removed from the token list and `a` is added.

Arguments can also be passed to a macro by using the `hash` character followed by a number.
For example, the output of code beneath is `This is a macro`.
{
    new LstListing('''
\def\macro#1\{This is #1\}
\macro\{a macro\}`
''')
}

It is also possible to pass these arguments in a different way, for example `\\def\\\u0061uthor(\#1,\#2)\{\#1, \#2\}` will expect two arguments surrounded by a pair of brackets and separated by a comma.
We can also pass macros as an argument.
Given `\\def\\\u0073urname\{Vervack\}` and `\\def\\\u0066irstname\{Titouan\}` for example,
we can call the previous macro: `\\author(\\\u0073urname,\\\u0066irstname)`.
However calling `\\author` using the following macro `\\def\\\u0066ullname\{(Vervack,Titouan)\}` causes the call to fail.
It does so because it expects a `\(` token but it found the `\\fullname` token as the argument has not been expanded yet.
This is the reason that we are able to finely control macro expansion.

To make the previous example work, we need the `\\expandafter` macro.
First, it removes the first token two tokens behind itself, then it expands the second token once and adds the first token along with the expansion back to the token list.
If we call `\\expandafter\\\u0061uthor\\\u0066fullname` we get the expected result.
There are a lot of different ways to control expansion and all of them are used in practice.
This makes macro expansion complex and shows how different is compared to functions being used in modern programming languages.

Variables can be declared as a macro as follows: `\\def\\\u0076arname\{A string\}`.
The `\\def` macro defines a macro with the name `varname` and when used it will output the body of the macro, `A string`.
The macro can be called by writing `\\varname` somewhere in the text.
The value of a macro is a string, to use integers we can use the `count` register.

There are 256 `count` registers, you can define one as follows: `\\count0=1`.
This assigns the value `1` to the first register.
Calculations can now be done on it, for example `\\advance\\\u0063ount0 by 1` will increase the register by one.

This also shows that arithmetics are handled differently in latex than in the languages we are used to.
There are no `\*, +, \-` or `/` symbols to define the basic mathematical operations.
To show a register, we can use the `\\the` macro, `\\the\\\u0063ount0` will output 1.

Using this programming model, libraries, called packages can be created.
Over the course of the past 38 years (the initial TeX release was in 1978), a lot of them have been created.
They offer all kinds of functionalities, ranging from the creation sheet music and graphs to providing the base to write letters and books.
This is one of the reasons why {lat} is often used for long and complex documents such as books, scientific papers and syllabi.

The goal of {lat} {cite('''latintro''')} is for the user to focus on the structure and content of the document and to let designers worry about the design of the document.
To make sure the document will look good afterwards, it is important to structure it using elements such as sections and paragraphs.
Because of the freedom given in WYSIWYG word processor, it is often forgotten to use styles, headers and so on.
This can cause inconsistencies to appear as the document grows.

Designers can use the very sophisticated typesetting of {lat} to create designs for well structured {lat} documents.
The typesetting improves readability by supporting kerning, ligatures,... and using the advanced Knuth-Plass line-breaking algorithm {cite('''texlba''')}.
The algorithm sees a paragraph as a whole instead of using a more naive approach and seeing each line individually.
Kerning places letters closer together or further away depending on character combinations.
A ligature is when multiple characters are joined into one glyph for example fi vs. `fi`.

{lat} also knows how to work with bibliographies by using programs such as Bib(La)Tex or Biber.
These are reference management programs that are very robust and makes certain all of your references are consistent.
They allow you to create the references outside of your main document, decreasing the amount of clutter in the document.

Whilst on the topic of including other files in your document, in {lat} you can split up your document into multiple smaller documents, allowing for easier management.
A common use of this function is to write every chapter, for example in a book, in a separate document and than all the chapters are imported into the main document.
This allows to easily remove or switch out different parts of a document. This is also possible in {pan} and the WYSIWYG editors.

Finally, {lat} employs a free and open source model, which is a big reason why it is so popular in the open source community.
As a result of this model, combined with its popularity and good scientific support, LaTeX has been integrated in many other applications.
A few examples are:
* MediaWiki {cite('''mwikilat''')}
* Stack Exchange
* JMathTex {cite('''jmathtex''')}
//TODO: add more examples, reddit?

{lat} is powerful but it is also complex and has a steep learning curve, because of this, simpler alternatives such as {md} have been created.

### {md}
`Markdown is a text-to-HTML conversion tool for web writers.`
`Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML).`

(Markdown, 2016)

The goal of {md} {cite('''markdown''')} is to be easy-to-write and read as a plain text document and as such is actually based on plain text emails.
Because of this, it attracts a lot of attention. It is for example very easy to create a new simple document, such as a short report.

It achieves this simplicity, by introducing a small and simple syntax {cite('''mdsyntax''')} that feels natural.
For example, to create a title you underline it with `minus` or `equals` characters.
To create an enumeration, you use `star` characters instead of bullet points.
An example {md} document is shown below:
{{
    Image i = image("The document rendered as HTML by the official markdown conversion tool", '''document''').scale(40);
    i.rightOf(new LstInputListing('''document.md'''));
}}

The simple syntax decreases the amount of possible syntax errors and allows for short compile times and wide IDE support.
Even without the help of an IDE {md} is very readable, as it was designed to be.

The syntax allows {md} to be easily translated into other formats such as PDF or HTML.
A tool to convert {md} to HTML is offered by the designers of the language itself, as stated above.
It is also cross-platform and as such widens the target audience of {md}.

To allow for some customisability, {md} allows you to use inline HTML.
In case {md} does not support what you want to do, HTML is what you use.
Tables are not a part of default {md} (though there are variations that have syntax for them, like Github Flavored {md}), so an example of how to create one using HTML is shown below:
{{
    Image i = image("The table document rendered as HTML by the official markdown conversion tool", '''htmltable''');
    i.rightOf(new LstListing('''
Below you can find an HTML table
<table border="1">
    <tr>
        <td>
            Element 1
        </td>
        <td>
            Element 2
         </td>
     </tr>
</table>
    '''));
}}

{md} is simple, but has almost no customisability. Because of this, solutions such as {pan} have been created.

### {pan}
{Chapter panAdv = (Chapter) parent()}
{pan} {cite('''pandoc''')} is a document converter, but it can do much more than just convert a document from one format to another.
Notably, it allows you to write inline {lat} in a {md} document, combining the power of both.
An example is shown below.
{
    LstInputListing pandocListing = new LstInputListing('''pandocExample.md''');
    return pandocListing;
}
{{
    pandocListing.leftOf(new Image("The output of the document to the left.", '''pandocExample.png'''))
}}

However, outside of the {lat} one, {pan} does not really have a programming model and instead works with so called filters.
A document in {pan} can be read and transformed into an Abstract Syntax Tree (AST).
The AST is read in a filter, then transformed and passed on to the next filter.

Filters can be written in a multitude of languages such as Haskell, Python, Perl,... .
They are then passed as a command line argument to the conversion command.
We illustrate this using an example from the {pan} tutorial on scripting {cite('''panexample''')}.
{
    new LstInputListing('''behead2.hs''')
}

(Pandoc, 2016)

The example above shows a filter written in Haskell.
It replaces all the headers of level 2 or more in a {md} file by paragraphs.
The `toJSONfilter` function constructs a JSON representation of the AST.
Using this, we find the headers of level of 2 or more and create a new paragraph.
The document can be created using the following command `pandoc -f SOURCEFORMAT -t TARGETFORMAT --filter ./behead2.hs`.

This example shows the power of {pan}, it can do its work directly on the AST.
This means that the source document does not have to be a {md} document, it could also use HTML or any other supported input format.

Using another one of these filters, PanPipe, you can execute programs defined outside of a document.
The stdout of the program will be inserted into the document and the stderr will be redirected to the stderr of {pan}.
An example is shown below.
{
    LstListing panShell = new LstListing('''
This document executes a shell command.
```{pipe="sh"}
echo "Hello world! I am " $(whoami)
```
    ''')
}
{{
    panShell.leftOf(new Image("The output of the document to the left.", '''panShell'''))
}}

Using {pan}, you can also declare templates, that allow you to use variables.
The variables are predefined (such as `\$body\$`\) or passed through the command line.
These can then be used in conditionals or loops.
You can see an example below.
{
    LstInputListing panLetter = new LstInputListing('''letterTemplate.tex''')
}
{{
    panLetter.leftOf(new LstInputListing('''letter.md'''))
}}

## Problem statement
We can see that these solutions all have there advantages, but there are also quite a few disadvantages.
We will discuss the most common ones for every solution underneath and afterwards we introduce the problem statement.

### Word processors
// TODO: consider templates
// TODO:
//Another problem with word processors is that their format often changes over the years.
//This means that your document might not show up the same, or at all, a few years after you wrote it.
The UI in WYSIWYG editors allows you to customise the document, you can insert other documents, tables, figures,... and adjust a lot of properties.
It is also possible to use macros using for example Visual Basic for Applications in Word to automate some tasks.
It can for example be used to remove leading tab characters from paragraphs.

However, it has trouble with inserting variables.
Because of this, it is very cumbersome to compute a simple expression like `x + y`.
To do this, you first have to open the Visual Basic Editor.
In there you create a new module in which you define your new variables as follows.
{
    new LstListing('''
    ActiveDocument.Variables.Add Name:="x", Value:=27
    ActiveDocument.Variables.Add Name:="y", Value:=2
    ActiveDocument.Variables.Add Name:="result", Value:=(Int(ActiveDocument.Variables("x")) + Int(ActiveDocument.Variables("y")))
    ''')
}

The result variable can then be inserted by selecting `Quick parts` in the `Insert` tab, selecting `Field`, then selecting `DocVariable` and finally typing in `result`.
This will insert the `result` variable into the document, but the variable will not be kept up-to-date.
To achieve that you have to right-click it and click `Update field`.

// TODO: include image?
In word processors small changes can also have big side effects on the document.
For example, you placed an image exactly where you wanted and later on, you add a newline somewhere higher up.
The reflowing of the text underneath it shifts the precisely placed image out of place.
These changes are not always immediately clear, which creates inconsistencies in the document.

Another problem that occurs with images, is that the caption does not move together with the image.
In the example below an image is inserted and a caption is added.
The image is then dragged to the end of the file and we see that the caption remains in place.
{
    Image wordCaption = image("An image with a caption", '''wordCaption''');
    return wordCaption;
}
{{
    wordCaption.leftOf(new Image("The picture was moved, but the caption did not move", '''wordCaption2'''))
}}

### {lat}
Even though {lat} offers customisability through a programming model, it is not perfect.
The programming model is hard to use and read, creating a steep learning curve.
It also makes {lat} seem complex, scaring away a lot of potential users.
A way to counter this complex look, is LyX {cite('''lyx''')}. This is a GUI around {lat} offering some of the most common WYSIWYG features, while still utilizing the strength of {lat}.
Even though the complexity can be hidden under a GUI, it is still there and error messages are as bad as they were before, as is discussed beneath.

Having a cumbersome programming model, {lat} makes it easy to create syntax errors.
When these are made {lat} shows an error message, but these are often unclear.
See the excerpt below for an example.
{{
LstListing a = appendContent(new LstListing('''
\documentclass{article}
\begin{document}
\begin{equation}
$a$
\end{equation}
\end{document}'''));
a.leftOf(new LstListing('''
line 4: Display math should end with $$.<to be read again>a $a
line 5: You can't use `\eqno' in math mode.\endequation ->\eqno\hbox {\@eqnnum }$$\@ignoretrue \end{equation}
line 6: Missing $ inserted.<inserted text>$ \end{equation}
'''));
}}
The message means that \$ is not allowed inside of an equation, but that is not clear from the error message.

As mentioned in {latexAdv.ref()}, the macro model does not work as we are used to in imperative and functional languages.
It requires a lot of work to keep up with the expansions and use the right expansion tools.
It also does not use a static type system while this could provide us with information needed for refactoring and auto-completion based on the context.

### {md}
{md} is simple but pays a hefty price for it.
All of the syntax elements have been hard-coded into the language meaning there is no room for customisability.
The only way to customise {md} is by embedding inline HTML.
This allows to create a solid structured model but it still does not allow for very much customisability.
There is no programming model that can provide the customisability.

While {md} is meant to be easily readable and writeable, HTML is not and using it thus decreases readability and cleanliness of your document significantly.
Once you use HTML in an {md} document, you also require a certain technical proficiency for the source document to be read or edited.
HTML also reintroduces the possibility of syntax errors and thus slows down the document creation.

### {pan}
{pan} allows you to execute exterior programs, but the only result is the stdout and stderr of the program.
These do not allow you to change the output afterwards because you have no more structure.
The structural elements such as sections and paragraphs have disappeared.
This decreases the amount of control on the final document.
For example, you create a binary tree using a 3rd party application.
Then you want to insert a new value into the tree, which requires it to be rebalanced.
However this is impossible as you lost all of the structure of the tree, it is only represented as a string.

To access the structure of the document, the AST can be used.
Transforming an AST afterwards however, does not allow for precise control either.
In {panAdv.ref()} we saw how we could replace all of the headers of a level higher than 2, but changing it for only a few would require us to find them.
If we could have done this inline or if we could redefine the meaning of the `\#` symbol, the problem would be avoided.

Finally, the variables used in {pan} have some limitations.
They can not be defined inline, only through the command line and they can only be used in templates.
This means that you can not easily embed variables and execute simple expressions such as `x + y`.

## Proposed solution: Neio
{Chapter goals = (Chapter) parent()}
To counter the problems occurring in the state-of-the-art solutions whilst retaining their advantages, we created a new markup language called `Neio` (read as neo).
// TODO: naam uitleggen?
Based on these solutions, the following goals were created for the Neio markup language:
- It has to be user-friendly and easy to get started with the language
- It has to use a modern programming paradigm
- It has to be highly customisable

The first goal is achieved by using a syntax like {md} for the documents.

To achieve the second goal we note that a document has a strong structure consisting of a lot of elements like chapters, sections, paragraphs and so on.
An object-oriented model, like the one in Java, is able to represent this structure well by using object for each element.
Inheritance allows us to easily make small changes to the elements for example changing the default font size of a certain kind of chapter.
We also chose this model because it is well known and as seen in {panAdv.ref()} and {latexAdv.ref()}, working with macro expansions or filters is not ideal.

Because it offers a powerful programming model that we can translate to, we chose to translate to {lat}.
It has also been used successively for decades and has proven that it can deliver very clean looking documents.
Later on more back ends, such as HTML, could be implemented, but that is outside of scope of this thesis.

### Target group
Neio targets anyone that is currently using {md} but wants to customise their document further.
For example, using Neio you can create citations and references, which is not possible in {md}.

By offering a simpler syntax and less foreign programming model than used in {lat}, we target {lat} users .
Lastly, offering a well-known, modern programming model that is more conventional than the macro model in TeX, we target {lat} package developers.
// TODO
//It can also be used by people without technical expertise if templates are provided.
//For example, given a template for a letter, even a non-technical person is able to quickly write down the contents of the letter and fill in the template variables.

# Design of the Neio markup language
In {intro.ref()} the state-of-the-art concerning document creation has been discussed and we concluded that improvements can be made.
In this chapter the Neio language is presented.
We explain how our decisions were reached and how they were affected by the presented solutions.

## Neio document
The typical files that a user will write are called Neio documents, these have to be as simple as possible.
As mentioned in {goals.ref()}, Neio documents are heavily based on {md}.
This allows us to make use of the widespread knowledge of {md} to increase the size of our audience and allow users to easily transition to Neio.

To illustrate some of the basic concepts we now present an example Neio document.
{
    String simpleDocument = '''
[Document]

# Chapter 1
This is some text in the first Paragraph.
''';
    Image i = new LstListing(simpleDocument).leftOf(image("The rendered document", '''simpleDocument'''));
    
}

Even if you are not familiar with {md}, you can immediately tell what this document represents. 
There is however a significant difference with {md}. 
In markdown the syntax is hard-coded into the language, a \# will always represent a chapter for example.
Neio however has no knowledge of what \# means.

Neio does not know about such syntax because everything is a method call, chained together to form an object model that represents the document.
The reason for doing so is simple, we want to be able to customise our documents!
For example, when you are creating a slide show, you want \# to create a new slide instead of a chapter.

Knowing this, we can now represent the document as a chain of method calls as follows:
{
    new LstListing('''
new Document()
    .#("Chapter 1")
    .text("This is some text in the first Paragraph");
    ''');
}

For this to work of course, every one of these method calls has to return an object.
In fact, every one of these methods will return an object that is a subtype of the `Content` class, anything in a Neio document that can be shown is a subtype of `Content`.
The `Content` class is the base class in Neio documents, like `Object` is the base class in Java.

Now is also a good time to explain a small syntactical difference with {md}, which you might have already noticed.
Every Neio document has to begin with a so-called document class. This is a concept borrowed from {lat}, and just as in {lat} it tells us what kind of document the user is trying to build.
We say that a Neio document  has to start with a document class, but this is not entirely correct.
You are allowed to add single- or multi-line Java style comments before the document, or anywhere else in the document for a matter of fact.
The following is thus also a valid document.
{
    new LstListing('''
// A single-line comment
[Document]
/*
 * Multi-line comments are also available!
 */
    ''');
}

To further understand this example we need to introduce the second kind of files available in the Neio markup language, Class files.

## Class files
Class files are very similar to class files in Java. They are the thriving force behind the Neio documents, they define all the object and methods that are used in a Neio document.
They are extremely important to the design of the language as they allow us to represent everything in the document with an object structure.
The use of this object structure is extensively used in Neio and examples of this will be shown further on.

As means of an introduction we will have a look at the `Document` class that was used as a document class in the previous section.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Document.no''');
}

Except for some variations on the syntax, such as using `namespace` instead of `package`, and the lack of access level modifiers, this is valid Java code.
The access level modifiers are automatically set to `private` for members and `public` for methods.
They do not have to be written explicitly as the default value is usually what the developer wants and it makes the class file just a little clearer and more concise.

Again though, I stand corrected, this would be valid Java code if not for the \# method.
In Neio class files, you are allowed to use symbols as a method name.
This is a feature that is necessary to allow a Neio document to be represented as a chain of method calls as otherwise you would have to actually write out a document as series of method calls,
or you would not be able to use symbols as syntactic shorthand.
All the symbols you can use for method names at this time are `\#, \-, \*, \_, \$, \|, \=, \^`, the backtick and the newline.
The newline character is recognised by the following regex `\\n\\r?`.
By using all of these symbols we are able to create Domain Specific Languages (DSL) for some things such as tables or structural formulas. This will be illustrated in Chapter 3.

To keep the language simple and to maximize reusability (as well as making the parsing somewhat easier) some functionality from the Java language was dropped.
It is for example not possible to create anonymous classes as this goes against the concept of reusability.
It is also not possible to create multiple classes in a single file.

## Newlines
{Chapter newlines = (Chapter) parent()}
Neio is newline sensitive, in the sense that newlines too are methods.
The superclass `TextContainer` of `Document` and `Chapter` defines the following method.
{
    new LstListing('''
/**
 * Handles newlines
 *
 * @return returns a new ContainerNLHandler
 */
ContainerNLHandler newline() {
    return new ContainerNLHandler(this);
}''');
}

The `ContainerNLHandler` will then further handle the flow of the document.
The code for `ContainerNLHandler` and `NLHandler` are added below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/ContainerNLHandler.no''');
}

{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/NLHandler.no''');
}

Our earlier example now translates to the following:
{
    new LstListing('''
new Document()
    .newline()
    .newline()
    .#("Chapter 1")
    .newline()
    .text("This is some text in the first Paragraph");
    ''');
}

We needed to do this because a newline in a plain text document has meaning, depending on the context it can mean something else entirely.
For example, a single newline in a paragraph should append the next sentence to the paragraph.
But on the other hand when we separate two text blocks with an empty line (thus two newlines), the blocks of text are seen as two different paragraphs.

It should also be noted that any text written in a Neio document gets translated to the `text` call as seen in the example above.
An implementation of the text method is seen `NLHandler`.
The reason for this will become clear later on.

We will see more advanced examples using newline in Chapter 3 that will further expose its benefits.
To avoid clutter, the `newline` method will not be shown in the further examples unless it is needed to understand the example.

## Language features
### Context types
{Chapter ctxTypes = (Chapter) parent()}
As said before, everything is a method call, but to be able to just chain any method to any other method, regular methods do not suffice.
We want to be able to call methods of different class files whilst constructing our document, but we do not want to specify what object we are calling the method on.
This is something that should be clear from the current structure of the file, a previously created object should have a method with the correct signature.

To be able to call the right methods, we need to introduce something called ContextTypes.
A ContextType combines an object, the actual type, with its context.
We will illustrate this using an example.

{
    LstListing context = new LstListing('''\n[Document]\n''');
    return context;
}

As we saw before this translates to the new call `new Document()`.
This is actually a ContextType of the newly created `Document` and `null` as there is nothing else yet.
We will call this ContextType `ct1`.

Lets add a chapter to it, when there are two elements, there should be some kind of context.
{
    Text ct2Caption = "In the image above we find ourselves at the *X*. We follow the red arrow upwards and find ourselves in Document. As Document contains the \# method, we call \# on Document and a Chapter is added to the Document , as represented by the green arrow.";
    LstListing context2 = image(ct2Caption, '''ct1''').rightOf(context.append('''\n#Chapter 1'''));
}

By adding this call our document translates to the following`new Document().\#("Chapter 1")`.
The addition of a second element allows us to see a ContextType in action.

To know where to find the \# method, we will recursively iterate over our context.
First we check the actual type of `ct1`, if we could not find the method there, we recursively proceed to check the context of `ct1`.
As you can see above in the source code of `Document`, there is indeed a method \# in there, so there is no need to look any further.
The current document translates to ContextType `ct2`, which contains the newly created Chapter and has `ct1` as context.

We continue by adding one more Chapter.
{
    LstListing context3 = image('''ct2''').rightOf(context2.append('''\n#Chapter 2'''));
}

Now when we look for the \# method in `ct2` we first have to check Chapter, but Chapter does not have this method.
We thus recursively check the context of `ct2`, which is `ct1`.
The actual type of `ct1` is Document, of which we know that it has a \# method.
As we have found the method we were looking for, \# will be called on the Document in `ct1`.
The ContextType that is created for this call is `ct3` that has the newly created Chapter as the actual type, but that has *ct1* as context.
This is because we have had to skip over `Chapter 1`, which shows us that `ct2` is not useful any more for the continued creation of the document.

Lastly we add a paragraph to the document.
{
    LstListing context4 = image('''ct3''').rightOf(context3.append('''\nThis is a paragraph.'''));
}

We check the actual type of `ct3` and immediately have a matching method, we thus call the method on `Chapter 2`.
The newly created ContextType `ct4`, contains the `Paragraph` as actual type and `ct3` as context.

The following structure is what we are left with.
{ image("The final structure built in the example", '''ct4''').scale(100) }

### Nested methods
Documents often have recursive elements such as sections or enumerations, as in Neio, everything is a method every one of these levels would have to be defined as a separate method.
That means creating a method for \#, \#\#, \#\#\#,... .
This is of course very cumbersome, even impossible at times, and we would like to only define it once as the behaviour should be mostly the same no matter how many symbols we use.
Usually only one property, such as font size, is effected by the number of symbols used in such a method call.
This is why nested methods were invented.
A method can be annotated with a `nested` modifier which means that this method implicitly takes an extra argument, an `Integer` that reflects the depth of this recursive method.
The depth of this recursive method is just the number of times the symbol has been used.
If we have a look at the `Chapter` class, we see that it has a nested method \#.
{
    new LstInputListing(1, 53, '''../../examples/0.8/lib/neio/stdlib/Chapter.no''');
}

If we would now call `chapter.\#\#("Chapter 1.1")` for example, it would translate to the following call: `chapter.\#("Chapter 1.1", 2)`.

An important thing to note is, that the regex matching a nested function, is `..+` where `.` is the symbol that is being used as a method name.
This means that the method that contains a single symbol, the method that defines the first level for example `\#(String name)`, should be defined elsewhere.
This has been done because the first level is usually special.
In case of an Enumerate for example, when we create the first EnumerateItem, not only an EnumerateItem but also an Enumerate has to be added.
Usually the object created by this method should also be added in a different place than the other objects.
Let us take the following example:

{
    new LstListing('''
[Document]
# Chapter 1
## Chapter 1.1
# Chapter 2
    ''');
}

{
    Image nestedCorrect = image("The correct ContextType representation", '''NestedCorrect''').floating();
    Image nestedWrong = image("The wrong ContextType representation", '''NestedWrong''').floating();
}

We would want *Chapter 1* and *Chapter 2* to be children of Document, while *Chapter 1.1* should be a child of *Chapter 1*. The ContextType representation of the document is shown in {nestedCorrect.ref()}.
If we now say that the nested modifier works on any level, including the first level, then the aforementioned structure would still be achieved, *but* the ContextType representation would be different.
The ContextType representation of this document would be as shown in {nestedWrong.ref()}.
This is because `\# Chapter 2` is now a method call on `ct1` instead of on `ct0` as the `nested Chapter \#(String name, Integer level)` method in Chapter would be the function that resulted from our lookup.

### Surround methods
A method could also be annotated with a `surround` modifier. This means that the method name surrounds a piece of text, this can be used to for example create bold text by surrounding it with stars.
This is needed to be able to easily annotate text and it also looks very natural.

Examples of surround methods are the ones available in Text.no.
{
    new LstInputListing('''../../examples/0.8/lib/neio/lang/Text.no''');
}

The text `This is \*bold\* text` will then be transformed into the following chain `text("This is ").text(\*("bold")).text(" text")`.

### Code blocks
{Chapter codeBlocks = (Chapter) parent()}
We have seen that we can use code in Neio class files and customise our document this way. But this does not allow us to do everything we want to.
We do not want to create a new document class every time we want to do something special. It is also not possible to add anything to a document class that does not exist.
Sometimes we might just want to change a property of some content, which is not possible as of yet.
For this reason, it is possible to add code blocks in a Neio document. The three different kinds of code blocks are explained below.
To avoid confusion, when you are writing text into a Neio document, we say that we are in Text mode.
While when we are writing code in a Neio document, we say that we are in Code mode.

#### Non-scoped code
{Chapter nsCode = (Chapter) parent()}
Now let us say that we want to create a `Document` that uses a special type of content that we have created.
For example, we like Fibonacci so much, that we have created a special `Enumerate` that is numbered according to the Fibonacci sequence.
The code for this new `Enumerate`, `FibEnumerate` is shown below.
We also show the code for the `EnumerateItem` that is used in `FibEnumerate`, `FibItem`.
{
    new LstInputListing('''../../examples/0.8/lib/neio/fib/FibEnumerate.no''');
}

{
    new LstInputListing('''../../examples/0.8/lib/neio/fib/FibItem.no''');
}

The only real thing that changed in this code, compared to their super classes `Enumerate` and `EnumerateItem`, is the code to translate the object, given in the `toTex()` method.
There is however another odd line present in the constructor of `FibEnumerate`.
It concerns the following line:
{
    new LstListing('''
addClassMapping(EnumerateItem.class, FibItem.class);
    ''');
}

For now, it is enough simply to know that this acts mostly as a factory.
For this example it means that if `FibEnumerate` or one of its children \(a `FibItem` for example\) were to create an instance of the class `EnumerateItem`, that it will actually create a `FibItem`.
The reason we say it, acts as a factory, is because we are asking for a new instance of some object to be created and what we receive is a new instance of that specific class, or one of its subclasses.
How this works will be explained further on, in Chapter 4.
The bottom line is that this line of code allows us to reuse the `\-` method that has been defined in `Enumerate`, to create a `FibItem` instead of having to redefine this method simply to create an instance of a subclass.
It also makes sure that we do not have to write a new factory every time we want to replace a general class by a more specific subclass, as would otherwise have been needed here.

Now to be able to get this `FibEnumerate` into a document all we have to do is open a code block and create a new `FibEnumerate`.
A non-scoped code block is represented as a pair of `\{\}`, where the `\{` is at the start of a line and the `\}` is followed by a newline.
The `\{` and `\}` can not appear on the same line. The reason for this will become clear further on.
Also note that a semicolon at the end of the last statement is optional, this is mostly useful in inline code blocks as we will see further on, but even in this case, it makes the document just a little bit easier and less prune to syntax errors.

{{
    image("The rendered Fibonacci document", '''fibDocument''').scale(25)
    .rightOf(new LstInputListing('''../../examples/0.8/input/testInput/fibDocument/fibDocument.no'''));
}}

The example above shows us that this works, but how exactly does this work, you might ask.
The reason that this works is because the new object is added to the current document and the following `\-` calls will thus be called on this object.
An object can only be added in this way through the last statement in a non-scoped code block and the object will only be added if it is a subtype of `Content`.
If the last statement does not return an object (a method call with a void return type or an assignment), nothing will be added.
It is also possible to explicitly return something from a non-scoped code block by using the `return` keyword.

To further explain this, and to explain how we could possibly call functions on an object we need to introduce a new concept called `this`.

#### This
{Chapter thisCode = (Chapter) parent()}
A Neio document has a concept of `this` like many programming languages do.
`this` will always refer to the last element that was created in Text mode.
But if that was the only way to interact with `this` we would not be able to call any methods (as we have nothing to call objects on) and we would not be able to add, modify or remove anything to/in the document either.
To show how exactly this works we will take a look at the translated form of the previous example.
{
    new LstListing('''
        new Document();

        FibEnumerate $var0 = new FibEnumerate()
        this.appendContent($var0);

        this.-(new neio.lang.Text(Item 1))
            .-(new neio.lang.Text(Item 2))
            .-(new neio.lang.Text(Item 3))
            ...
    ''')
}

We see that a separate statement was created for everything above our code block and that the code in our code block was than directly included into the code.
The last statement gets assigned to a variable and `appendContent` is called on `this`.
This is always what will happen when you use a non-scoped code block, this means that the compiler knows about the `appendContent` method.
Another example to further illustrate the use of non-scoped code blocks and `this` will be shown later on.
After appending the content, a new statement is started, containing our well known chain of method calls, but the first method is called upon `this`.

In the next stage of translation, variables will be assigned to the objects and this will be filled in with the last object created in Text mode, or the `Content` returned in a non-scoped code block.
The next step of translation is shown below.
{
    new LstListing('''
        Document $var0 = new Document();

        FibEnumerate $var1 = new FibEnumerate();
        FibEnumerate $var2 = $var0.appendContent($var1);

        $var2.-(new neio.lang.Text(Item 1))
            .-(new neio.lang.Text(Item 2))
            .-(new neio.lang.Text(Item 3))
            ...
    ''')
}

To show how code blocks work in combination with this, we will show another example.
{
    new LstListing('''
[Document]

This is the first paragraph
{
    Chapter c1 = #("Chapter 2");
    c1.*(new Text(c1.title()));
}

This is a paragraph
    ''');
}

Now to explain the example, in the example a `Document` is created and a `Paragraph` is added to it in Text mode.
Then in Code mode we create a new, `Chapter`, called `Chapter 1` using the `\#` method.
We then create a new `Enumerate` using the `\*` method and finally we add a `Paragraph` in Text mode.

The translated version of this example is shown below:
{
    new LstListing('''
new Document().newline().newline().text("This is the first paragraph").newline();

Chapter c1 = this.#("Chapter 1");
$var0 = c1.*(new Text(c1.title));

this.newline().newline().text("This is a paragraph");
    ''')
}

In further translation the first `this` will result into the `Document` while the second this will be `c1`.
The reason that the first `this` will be the `Document` instead of `Paragraph`, is because of `ContextType`s.
`Paragraph` and `ContainerNLHandler` do not have a `\#` method, but `Document` does, as is shown in the following UML (only public members are shown to prevent clutter).
{
    List<String> show = new ArrayList<String>();
    show.add('''neio.stdlib.Paragraph''');
    show.add('''neio.stdlib.ContainerNLHandler''');
    show.add('''neio.stdlib.Document''');
    new Uml('''./project.xml''', '''neio''').show(show);
}

A last point to note is that since your code is directly inserted into the translation, all the variables you have defined will be available from there on, and will take up their space in the current namespace.
This means that you can use your variables in other code blocks, but also means that generic identifiers like `i` should be avoided as you might want to be able to use this identifier again later on.

#### Scoped code
If all you want to do, is execute some arbitrary code without corrupting your namespace, a block of scoped code is the way to go.
The use of a block of scoped code is illustrated below.
{
    new LstListing('''
[Document]
# Chapter 1
{{
List<String> l = new ArrayList<String>();
l.add("upquote");
l.add("pdfpages");
l.add("url");
for (int i = 0; i < l.size(); i = i + 1) {
    addPackage(l.get(i));
}
}}
    ''');
}

In this example a `Document` is created but to be able to use it for our needs, we need a few more packages that are not included by default in `Document`.
We also do not want to think of very descriptive identifiers for our variables as it is just a simple operation, the name `l`should suffice.
Normally these variables would be defined in a short function and we would thus not have to worry about shadowing or overriding this name.
But as we saw in {thisCode.ref()}, our code is just inserted straight into the final document.
The difference is that a block of scoped block is inserted into its own scope. It also does not automatically add anything to the document like
non-scoped code does.
The previous example is translated to the following Java.
{
    new LstListing('''
Document $var0 = new Document();
ContainerNLHandler $var1 = $var0.newline();
Chapter $var2 = $var0.hash(new neio.lang.Text("Chapter 1"));
ContainerNLHandler $var3 = $var2.newline();
{
    List<String> l = new ArrayList<String>();
    l.add("upquote");
    l.add("pdfpages");
    l.add("pdfpages");
    for (int i = 0; i < l.size(); i = i + 1) {
        $var0.addPackage(l.get(i));
    }
}
    ''');
}

Another good reason for wanting to use scoped code, is when you only want to call a function that already adds an object to the `Document`.
Using non-scoped code, this object would be added to the `Document` again through `appendContent` as seen in {thisCode.ref()}.
An example is shown below.
{
    new LstListing('''
[Document]

{{
    image("image1")
}}
    ''');
}

This code creates an `Image`, but also adds it to the `Document`, as we do not want to add it twice, or invent an identifier for it, we use non-scoped code.
The code for the image function is shown below.
{
    new LstInputListing(53, 75, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''')
}

#### Inline code
Inline code is the last type of code blocks and is very like non-scoped code.
The difference is that it only allows one statement, and the opening and closing brackets should be placed on the same line.
As the name implies, this is code that is meant to be used inline. A few examples of this are shown below.
{{
    image("The rendered form of the example to the left", '''inlineCode''')
    .rightOf(new LstListing('''
[Document]

# Chapter 1
I created a document that only contained one chapter.
{
    Chapter c1 = nearestAncestor(Chapter.class);
    Integer printing = 1;
    Integer driving = 2;
    Integer timeWasted = 14;
}

It is called { c1.title() } and it cost me { printing + driving + timeWasted }!
    '''))
}}

In the example we get the first `Chapter` structurally above us, define some integers, and then later on we get the title of this chapter and do a calculation with our integers.
The result of this is returned and passed to the `text` method, as would normally happen with a piece of text.
Note that whatever comes out of the inline code block is first transformed into a String using the toString() method.

The paragraph thus translates into the following chain.
{
    new LstListing('''
this.text("It is called ").text(c1.title().toString()).text(" and it cost me ").text("" + (printing + driving + timeWasted)).text("!");
    ''')
}

### Text
Something that has not been noted yet, is that most of the time, we do not actually use Java `String`s.
What is used most of the time is Neio Text. Neio Text (in Code mode, not in class files) is created like Java `String`s, by enclosing some text with a pair of doubles quotes \(`\"`\).
A Java String is still sometimes needed and can be created using a pair of triple, single-quotes \(`\'\'\'`\).
We use three quotes, as a pair of single quotes still represents a Java Character, while two quotes would be very confusing when used in combination with double quotes in a non-monospace font.
The inspiration of using three quotes came from the multi-line String literal in Python.
The difference is that Neio text can contain anything you would type in Text mode, which includes code blocks, you can thus effectively endlessly nest Text and Code mode.
The reason we use Neio text for most things instead of Java `String`s (just have a look at a few of the methods in the UML shown below), is because Neio text can be marked up, by using surround methods for example.
{
    List<String> showTC = new ArrayList<String>();
    showTC.add('''neio.stdlib.TextContainer''');
    new Uml('''./project.xml''', '''neio''').show(showTC).scale(100);
}

We could for example create a bold Chapter using the following code `new Chapter\(\*Bold chapter\*\)`.

## Considerations
{Chapter considerations = (Chapter) parent()}
Whilst constructing the language a few other things were considered but not implemented, they will be discussed below.
#### Static typing
The language has been designed using static typing.
The reason for this is, that while we are writing a Neio document in Code mode, or we are writing a Neio class, we can be notified of possible type mismatches.
This decreases the time spent debugging and spend waiting on the compiler as you weed out one type mismatch after another.
It also allows you to create a safer program as type errors might be caught at compile time when using static typing.
On the other hand when using dynamic typing, type errors will only show up at runtime.
With the help of an IDE, we also do not really have that much more typing to do than when we would be using dynamic typing.
The language has been designed with static typing in mind, and types have been incorporated into the compiler, but the necessary checks are not yet in place.
At this point in time, when a type error appears in the code, we will get a `LookupException` when we are looking for that method or variable.
In the future, checks should be placed and appropriate errors should be thrown that make clear where exactly the error occurs.

#### Security
Another issue that we have considered is security. As it is possible to directly execute Java code, security is an issue.
However, security is also an issue in {lat} as has been shown in several articles {cite('''checkoway2010text''')} {cite('''checkoway2011don''')}.
Since our language is more readable than {lat} it might be easier to spot for people who understand code, that the document or library contains malicious code, than it is to spot malicious code in a {lat} document.
Adding a layer of security on top of Neio would require a lot of effort and research and is not in scope of this thesis.
Thus we conclude by saying that we known there is a security risk, but dismissing it should be seen as future work.

# Supported document types and libraries
This chapter will go into some more details about what document types can be handled by Neio, and how to specifically build these kind of documents.
We will also discuss which libraries have been recreated in Neio to allow for a wide use of the language.

## Document classes
It is important to note that to create complete document classes would require a lot more work than was available for this thesis.
If we just have a look at the user guides of Memoir {cite('''memoir''')} or KOMA-Script {cite('''komascript''')}, we see that they consist of 609 and 419 pages respectively.
This is not something we could hope to reproduce in the scope of this thesis.

The simplest of documents can be created using the `Document` class.
It provides syntax to create anything that {md} can create, and on top of that, it allows you to create tables, {lat} math, uml,...
It also allows you to use the code blocks defined in { codeBlocks.ref() }, to customise your document.
For example, it is possible to place two `Content`s next to each other by using the `leftOf` and `rightOf` methods that are defined in the `Content` class.
The code of these methods is shown below.
{
    new LstInputListing(118, 182, '''../../examples/0.8/lib/neio/lang/Content.no''')
}
This code takes the parent from one of the two `Content`s, the base, and links the other Content to the base.
The implementation creates a root {lat} `Minipage` {cite('''minipage''')} if these are the first two objects in a row to be placed next to each other, otherwise it just wraps the two `Content`s in a `minipage`.
The root `minipage` takes up the total width, while the `minipage`s that wrap the content take up 1/children of the width.

Another way of implementing this, that would probably have worked better, was through `TikZ` pictures.
This would have been better because it allows you to easily set any two things next to each other or above/beneath each other.
`Minipage`s require a lot more manual work, they might also split at a page-end which is not what we really want.

The `Document` document class can thus be used to write simple documents, such as small reports on various tasks.

### Book
A prime subject of writing a book, is this document itself. The entirety of this book has been created in a single Neio document.
// TODO: Not true
The way we do this is by creating a new `Document` class that represents our {lat} template.
In this case the template is implemented in the `Thesis` class given below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/thesis/Thesis.no''')
}

It also says that any `Chapter` that is automatically created, typically by the `\#` method in `Document` or `Chapter`, should be an instance of `ThesisChapter`.
This is done through the following line.
{
    new LstListing('''addClassMapping(Chapter.class, ThesisChapter.class);''')
}

A `ThesisChapter` just redefines a chapter so that it translates into the {lat} `chapter` macro when it is level 1 instead of directly calling the {lat} section macro.
{
    new LstInputListing('''../../examples/0.8/lib/neio/thesis/ThesisChapter.no''')
}

It extends the `Document` class and adds its own packages and creates its own {lat} preamble.
It also provides a method that will initialise the main matter, which contains a Table of Contents (ToC) using the following line.
The code for a ToC is shown below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Toc.no''')
}

We can also add things to a document class ourselves which might allow us to reuse other document classes
For example, to add an abstract to the `Thesis` document class, we just have to create an `Abstract` class that extends `Content` and add it to the document at the right time.
This allows us to add more functionality to a document class, without having to modify the document class itself, or without having to create a new one, for example `Thesis` and `ThesisWithAbstract`.

To add an abstract , we could initialise an `Abstract`, this `Abstract` might then overwrite the `newline` function to create an `AbstractNLHandler`.
The `AbsttractNLHandler` can then override the `text` method to initialize itself, as an abstract is just a block of text.
Overriding the `newline` method in the `AbstractNLHandler` allows us to escape this \"Abstract mode\" by typing an empty line.
The code to for `Abstract` and `AbstractNLHandler` are shown below, an example of what the output looks like can be found at the beginning of this document.
// TODO refer to extended Abstract

### Other document classes
To be able to create an article, a letter, or anything else, the only thing we would have to do is create a new Neio class for this document class.
This Neio class will then implement its own {lat} preamble and decide what packages to include by default and it might have to redefine what types of objects should be used using `addClassMapping`.
It might also add methods to be filled in, using a code block, or by overwriting methods and making use of the newline handlers.

For example, you might create a `LetterHeader` class that represents the header of a formal letter.
This header requires some information about the writer, the name, the addressee,....
One way to fill these in is just by passing them to the constructor of `LetterHeader` or by using setters defined in `LetterHeader`.
Another way to do this, is by overwriting some methods in `LetterHeader`.
We could overwrite the `\#` method to represent the name of the author, and `\-` to represent the addressee for example.
Another possibility is to used nested methods for this, `\#` represents the author, `\#\#` represents the addressee and so on.

Yet another way would be to create objects for the parameters we need (grouping some together if that makes sense) such as `Author` and `Addressee`.
We then implement a method, let us take `\#` once more, in `LetterHeader` that creates a new `Author` and returns it.
We then override a method, the same or a different one, in `Author` that creates the `Addressee` and returns it.
The advantage of this last step is that the structure of the letter is well split up and is enforced on the user.
Forgetting to define the `Author` should be immediately noticeable as the method to create the `Addressee` should not be known yet without creating the `Author` first.
On the other hand this is also more prune to error as people tend to forget things all the time.
// TODO: implement at least one of these

### Slides
// TODO: What do we do with slides?

## Libraries
{Chapter libraries = (Chapter) parent()}
To show what the language is capable of a few libraries were created or reimplemented. All of the currently available libraries in Neio will be explained below.
Note that none of these libraries are complete and would require a lot more effort to reach a state of completion.
Just having a look at the manuals of a few popular libraries such as TikZ{cite('''tikzman''')} we can see that more time is needed to write such a library than there is available for this thesis.
The libraries that were created, are meant for illustrative purpose, to show what Neio is capable of.

### BibTeX
The library created for BibTeX is one of the easiest ones created for Neio.
The implementation is just a binding to LaTeX and does not really allow for a lot of customisation as we do not have an object model of the BibTeX file.
We chose to implement BibTeX this way to illustrate that binding to LaTeX is not very difficult, and because we would have had to create an entire parser for BibTeX to be able to create the object structure needed to have full control over the BibTeX files.
As the BibTeX format is quite complicated we felt that our time was better spent elsewhere.
This is mainly because the only thing we require of BibTeX for this thesis, is to allow us to easily quote articles, websites and so on.
The code for our implementation of BibTeX can be found below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Bibtex.no''');
}

A BibTeX can now be added through the `addBibtex` method in `Document` and we can cite an entry by using the proxy method, `cite`, in `Document`.
{
    new LstInputListing(60, 82, '''../../examples/0.8/lib/neio/stdlib/Document.no''');
}

Lastly we show the code for the `Citation` class.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/Citation.no''');
}

The `Citation` class is a subclass of `Text` as we call it through an inline code block.
All the cites in this thesis have been provided through these classes and are called as below.
`key` is a Java String as it is used to do a lookup on the BibTeX entries, it should not be allowed to be marked up.
{
    new LstListing('''
[Document]
This is how we cite something {cite(\u0027''key\u0027'')}.
    ''')
}

### References
The way references have been implemented is quite straightforward.
Any class that implements the `Referable` interface, such as `Chapter` or `Image`, can be referenced by calling the `ref` method.
The way we typically go about a reference is as follows.
{
    new LstListing('''
[Document]
# Chapter 1
{Chapter chap = (Chapter) parent()}

In {chap.ref()} we will explain references.
    ''')
}

What we use here is a little trick to be able to get the `Chapter` into a variable.
What happens is as follows, a `Chapter` is created using the `\#` method and then the `newline` method is called upon it (this method has been inherited from `TextContainer`).
A `NewlineHandler` always takes the object that created it as a parameter in its constructor so that it can refer to it later on.
The `parent` call in the inline code block is thus called on the NewlineHandler, more specifically the `ContainerNLHandler`.
As the parent of a `ContainerNLHandler` is a `TextContainer`, a cast to `Chapter` is needed.
The code block is allowed to be an inline code block instead of a non-scoped code block because the statement in it is an assignment and thus returns nothing.
To reference an object {lat} needs a unique label, we use the hashcode of an object for this as it is easy to retrieve at any time and it is unique.
The newline method from `TextContainer` as well as the `ref` method in `Chapter` and the `Referable` interface are shown below.
{
    new LstInputListing(12, 19, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''');
}

{
    new LstInputListing(102, 119, '''../../examples/0.8/lib/neio/stdlib/Chapter.no''');
}

{
    new LstInputListing('''../../examples/0.8/lib/neio/lang/Referable.no''');
}

As we need a variable to reference something, this means that the object we want to refer to has to be available when we want to refer to it.
This means that we can not refer to things that are defined later on in the project, which {lat} can do.
{lat} is able to do this because it compiles more than once and is able to gather the information needed to create a reference in one of the earlier runs.
For Neio to be able to do this, we would have to do something similar as we can not simply let the compiler create the object we want to reference in advance.
This is not possible because the creation of an object is dependent on its context.

### {lat} math and amsmath
As mentioned in {latexAdv.ref()}, {lat} is very good at typesetting mathematical formulas.
As such it is something that we could not forget about.
Two ways to make use of the {lat} math and the amsmath package have been created.
The UML below shows the currently implemented set of objects in the Neio math library.
{
    new Uml('''./project.xml''','''neio.stdlib.math''')
}

To create an inline math formula, in {lat} this is done by surrounding some text with a pair of `\ $`'s, we create an instance of the `InlineEq` class.
The only method that has been implemented for it thus far is `sqrt` so we will show how we can create an inline square root.
{
    new LstListing('''
{
    Integer base = 2;
    Integer arg = 10;
}
${ieq().sqrt("{base}", "{arg}")}$
''')
}

As you can see we also make use of the `\$` operator, in our case it is a surround method defined in `Text`.
What we do next is a bit tricky, inside the surround method, we create an inline code block, and in it we create an `InlineEq` on which we call the `sqrt` method.
The reason we have to open this code block is because the contents of a surround method has to be a text and in normal text we can not call functions.
The arguments that are passed to the `sqrt` method are also special, each of the arguments is an inline code block wrapped in a Neio text.
Once again, this has been done because we need to be able to pass `Text` to the `sqrt` method, not just an integer.
A solution for this is proposed in Section 5.3.

Continuing the example, it is also possible to explicitly create an equation, in {lat} this is done using the `equation` environment.
{
    Image mathExample = new LstListing('''
{{
    eq().nonu().sqrt("{base}", "{arg}");
    eq().^("{base}", "{arg}").=().v("{Math.pow(base, arg)}");
}}
    ''').leftOf(image("The rendered form of the example to the left", '''mathExample'''))
}

The code above creates two `Equation`, on the first one it disable numbering through the `nonu` method and calls sqrt on the equation, as shown before.
In the second equation we use the `\^` method to create an exponentiation and use the `\=` method to create an equation from it.
The `v` method creates a `Value` and calculates the actual value of what has been typeset before it.
To be clear, everything except for the `Math.pow()` typesets something, but computes nothing.
This can be clearly seen in {mathExample.ref()}.
As most of the code in this library is straightforward, does nothing new and is a direct translation to {lat}, we only show the code for `Eq` class.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/math/Eq.no''');
}

### {lat} tables
Tables are one of the main things missing in {md} and is one of the things people have the most problems with in {lat}.
As such we tried to make a table that is simple to create, that is readable in source code and that allows you to easily edit values in the table later on, making it so we do not have to inline all of the changes, making it hard to read how the table.
The table is created like you would create an ASCII table, with pipes, spaces, dashes and values for the elements of the table. An example is shown below.
{
    new LstListing('''
[Document]
In the table below you can see the results of the 33rd 12urenloop of the University of Ghent:

|      Student club      | Rounds | Seconds/Round | Dist (km) | Speed km/h | 
----------------------------------------------------------------------------- 
| HILOK                  |  1030  |      42       |   298,70  |   24,89    | 
| VTK                    |  1028  |      42       |   298.12  |   24.84    | 
| VLK                    |   841  |      51       |   243.89  |   20.32    | 
| Wetenschappen and VLAK |   819  |      53       |   237,51  |   19.79    | 
| VGK                    |   810  |      53       |   234.90  |   19.58    | 
| Hermes and LILA        |   793  |      54       |   229.97  |   19.16    | 
| HK                     |   771  |      56       |   223.59  |   18.63    | 
| VRG                    |   764  |      57       |   221.56  |   18.46    | 
| VEK                    |   757  |      57       |   219.53  |   18.29    | 
| VPPK                   |   689  |      63       |   199.81  |   16.65    | 
| SK                     |   647  |      67       |   187.63  |   15.64    | 
| Zeus WPI               |   567  |      76       |   164.43  |   13.70    | 
| VBK                    |   344  |     126       |    99.76  |    8.31    | 
    ''')
}

{{
    image("The rendered form of the table given above", '''tableExample''')
}}

First of all, we note that it does not matter how many spaces are placed in side the elements of the table.
The way this table is build is by mixing the use of normal method calls of `\|`, a nested call of `\-` and by making use of a NewlineHandler.
The table is created by the `\|` method in `TextContainer`, so that it van be used in `Chapter`s as well as `Document`s (they are both subclasses of `TextContainer`).
{
    new LstInputListing(96, 109, '''../../examples/0.8/lib/neio/stdlib/TextContainer.no''');
}

The `TableRow` that is returned form the the `\|` method is `TableRow` that is stil under construction.
We continue building it by repeatedly calling the `\|` method on it, this time this method is located in `TableRow`.
The code for the `TableRow` and `TableElement` are shown below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/TableRow.no''');
}
{
    new LstInputListing('''../../examples/0.8/lib/neio/stdlib/TableElement.no''');
}

As you can see in the `TableRow` class, in the DSL we created, a `\|` method without any arguments, denotes the end of a `TableRow`.
To continue building the table, we use a `TableNLHandler` that has been created in the `newline` method of the `TableRow`.
We use the nested '\-' method in this handler to be able to insert newlines.
In our DSL the length of the nested method is ignored, but it could be used to measure the width of a table for example.
The handler also offers the `\|` method which appends a new `TableRow` to the `Table`.

Finally we can write an empty newline to get out of the DSL for creating a `Table` because of the `newline` method in the handler.
// TODO: Maak een getter voor de elementen in een table

The following libraries that were implemented are more domain specific and less generally usable.
However this shows that we can use Neio to typeset a wide variety of different documents.

### Red black trees
{Chapter rbtChap = (Chapter) parent()}
Red black trees are trees that are constantly update according to a defined algorithm.
When we want to show a red black tree in {lat}, we can typeset an instance of such a tree using `TikZ`.
Or we could create it in a third party program and include an image of an instance of such tree in our document,
this is a solution that would also work {md}.

However, since an algorithm is used, and we have a programming model, could not we just build the tree and then display it?
It turns out that we can.
All that we have to do is take some code that can generate red black trees and add a display method to it.
We show an example of the red black trees in use.
{
    new LstInputListing('''../../examples/0.8/input/testInput/rbtDocument/rbtDocument.no''');
}
{
    Image rbtExample = image("The rendered form of the above example", '''rbtExample''').scale(40)
}

The rendered document is shown in {rbtExample.ref()}. As we can see it is very easy to create and show
a red black tree. We could do this for any tree or graph as long as we have code for it and write a method
that can display it. As showing the algorithm to create red black trees is not the purpose of this example,
we only show the code to display it and to append something to it.

{
    Ranges rbtRanges = new Ranges().add(38, 53).add(170, 208);
    new LstInputListing(rbtRanges, '''../../examples/0.8/lib/neio/stdlib/graph/RedBlackTree.no''');
}
{
    new LstInputListing(124, 166, '''../../examples/0.8/lib/neio/stdlib/graph/RedBlackNode.no''');
}

We also show the {lat} code that is generated for the first of the three trees. This code is not that 
easy to read, hard to write and thus prune to syntax errors. This code is also newline sensitive, placing
empty newlines between the entries will make it so that your document no longer compiles. The code for the
next tree is very similar, but it is hard to reuse this code.
{
    new LstInputListing('''rbtDocument.tex''')
}

Note that this tree is not optimally implemented, in our case when we append something to the tree, we 
completely clone it and then add a new node to this new instance. The red black tree in this example also
only works for integers.
The reason we clone the tree every time we insert a new value is because otherwise all three of the trees 
would all be shown exactly the same and they would all show the last version of the three.

### MetaUML
{Chapter umlChap = (Chapter) parent()}
The next example has already been used a few times in this document.
Every UML diagram up to now was created using a UML library implemented in Neio.
It is also a little different from the other libraries we have seen thus far as it does not directly translate
into {lat}. Instead we are making use of MetaUML {cite('''metauml''')}.
A high-level overview of how we create UML diagrams will be given here, but a lower level overview will be given
in Chapter 4. We will start out with an example.
{
    new LstListing('''
[Document]
{
    new Uml(\u0027''./project.xml\u0027'', \u0027''neio.stdlib.graph\u0027'')
}
    ''')
}
{
    new Uml('''./project.xml''','''neio.stdlib.graph''')
}

This code reads the `project.xml` file, that tells it what project we want to create UML for.
The second parameter is the namespace the uml should be created for.
It is also possible to only show a few classes, or to also show private and protected members.
This is shown in the example beneath
{
    new LstListing('''
[Document]
{
    List<String> list = new ArrayList<String>();
    list.add(\u0027''neio.stdlib.uml.Uml''\u0027);
    list.add(\u0027''neio.stdlib.uml.UmlClass''\u0027);
    new Uml(\u0027''./project.xml\u0027'', \u0027''neio.stdlib.uml\u0027'').scale(100).show(list).showPrivate();
}
    ''')
}
{
    List<String> list = new ArrayList<String>();
    list.add('''neio.stdlib.uml.Uml''');
    list.add('''neio.stdlib.uml.UmlClass''');
    new Uml('''./project.xml''','''neio.stdlib.uml''').scale(80).show(list).showPrivate();
}

As the code for this library is over 600 lines long, we will not show all of the code.
To get an image out of this, we output our object structure to the MetaUML format, instead of {lat}.
And then run it through the `mpost` command line program which generates TeX code for the UML, which we 
can then include. The problem with the MetaUML tool is that positioning is not done automatically.
The way it was implemented in our case is a bit like a tree.
We build a tree of levels, the first level contains all the classes that have no super class to be shown as well as the highest level classes.
Subclasses are shown on the level beneath their super class.
For example, `ThesisChapter` is a subclass of `Chapter`, which is a subclass of `TextContainer`.
If we now show these three classes, they will be displayed one under the other because we built a tree with 
three levels. To visualize how the levels are being used, we show this example below but also add the Bibtex class 
to the UML , as it has no connection to the other classes.
{
    List<String> list2 = new ArrayList<String>();
    list2.add('''neio.thesis.ThesisChapter''');
    list2.add('''neio.stdlib.Chapter''');
    list2.add('''neio.stdlib.TextContainer''');
    list2.add('''neio.stdlib.Bibtex''');
    new Uml('''./project.xml''','''neio''').scale(80).show(list2).showPrivate();
}

Note that our implementation of UML diagrams only shows what it is asked to show (hence there are no uses 
arrows) and only draws inheritance arrows for what is shown. This is done to avoid clutter.
// TODO: talk about DOT

### Chemfig

### Lilypond
{Chapter lily = (Chapter) parent()}

# Implementation
Next to designing a language, a compiler to be able to actually use the language had to be build.
How we implemented the compiler, as well as some lower level concepts used in Neio classes, will be explained 
in this chapter.
// TODO: MetaUML and commands
// TODO: addMapping
## Used libraries and frameworks
To be able to build the compiler, we made few of a few open-source libraries and frameworks. They will be 
explained in this section. The number of libraries or framework that we used is rather limited, only three 
of them were used.

### ANTLR4
{Chapter antlr4C = (Chapter) parent()}
The ANTLR4 {cite('''antlr4''')} library is an open-source parser generator released under the BSD license.
It is used to parse all of the Neio files, the Neio documents and the Neio classes.
We used ANTLR4 in the following way.
First we created two grammars, consisting of a parser and a lexer, for the Neio documents and classes, thus four files in total.
These are written using the ANTLR4 DSL.
These grammars are then fed to the `antlr4` command line tool, this tool generates Java classes using the grammars 
you defined.
The ANTLR4 Java classes provide us with an interface that makes use of the Visitor pattern.
Using the visitor pattern, we visit every rule and terminal for a given file.
Whilst visiting these, we build an Abstract Syntax Tree (AST) of a given file which we can then manipulate further on.
The ANTLR4 grammars and visitor classes thus form the front end of our compiler.
The objects that are used in this AST, are objects defined in Jnome and Chameleon.

### Chameleon and Jnome
Chameleon and Jnome are both projects that were developed by professor van Dooren and released under the MIT license.
Chameleon {cite('''chameleon''')} is a framework that allows you to model a programming language, or as we have 
shown in this Thesis, a markup language. It does so by providing a lot of objects that represent concepts that are 
commonly used in programming languages. A few examples of such objects are the following:
`Expression, VariableDeclaration, Type, MethodInvocation, InfixOperatorInvocation,...`.

Jnome {cite('''jnome''')} uses Chameleon and implements the front end and back end of a compiler specifically for the Java language.
It can read Java and build an AST from it (using ANTLR3), thus it is a front end for the Java language.
To be able to do this it extends the object model available in Chameleon with Java specific objects.
It is also able to write out Java code, given an AST built from Jnome and Chameleon objects.
This part is the back end of the compiler.

Jnome can read entire Java projects at once, in our compiler for example, it loads the entire Java library.
This is needed because our objects use Java objects, such as `String`s.
It will read all of the source files and libraries that are specified in a file called `project.xml`.
This file was mentioned earlier in {umlChap.ref()}.
This same file is used to read Neio projects in our compiler. The `project.xml` for the Neio compiler is shown below.
{
    new LstInputListing('''project.xml''');
}

Having obtained an AST in {antlr4C.ref()}, we now manipulate it in the middle end of our compiler.
After the manipulations have been completed, we write it out using the Jnome back end.

## Compile flow
Now that all parts of the compiler have been introduced, we show a diagram that depicts the flow a source file 
from Neio source up to to the final {lat} file.
{
    Image compileFlow = image("Illustration of how a Neio document is compiled. Neio class files translate to Java classes, Neio script files to a Java file with a main function. This then gets output to TeX using the Neio standard library", '''CompileFlow''');
    return compileFlow;
}

First of the Java and Neio library (the Neio class files) are read by the front end of the Neio compiler and translated into an AST.
Then Neio documents are read by the front end and it is also transformed in an AST.
The latter AST is past to the middle end of the compiler and is transformed to an object model that can be output to valid Java.
Then the transformed AST and the ASTs for the Neio library are passed to the compiler back end which will generate the final Java code.
This final Java code will then be compiled and executed again.
During the execution, resources might be created, if so, they can be used in the next step.
This next step is the building of the document to a final representation.
The way it always happens at is the time is as follows.
The `TexFileWriter` is invoked with the root of the AST of the Neio document, this will call `preTex` and `toTex` 
on this root.
`preTex` allows a document to prepare itself for being printed to {lat}. A common preparation is to add a package that is uses to the root document.
`toTex` does what is says and just creates a {lat} representation of the object.
Once that is completed, it will write out this TeX string to a file named the same as the Neio document
but with the TeX extension. Finally the path to this new TeX file is passed to the `TexToPDFBuilder` which will 
compile the LaTeX code.
The code for these two files is shown below.
{
    new LstInputListing('''../../examples/0.8/lib/neio/io/TexFileWriter.no''');
}
{
    new LstInputListing('''../../examples/0.8/lib/neio/io/TexToPDFBuilder.no''');
}

## Translation
### Reasons for choosing Java
The reason we chose for Java was multi-fold. First and foremost, we already had a front- and back end available
for Java thus this saved us a lot of time.
A second reason is because Java is platform independent which does not restrict us to a single operating system.
Java is also very well known in the current world of computer science, which is why we chose to base our programming 
model on it. Since the Neio semantics now resemble the Java semantics so well, the reasons for going with Java are enforced.

### Fluent interface
We tried to make use of fluent interfaces as much as possible, in the design of the language, by using method chains.
But also in the libraries we implemented in {libraries.ref()}.
We chose to this as it imposes less boilerplate code (no constant variable declarations for example) and because it is clearer to read what we are doing.
Instead of passing a ton of arguments to one method, we split it up in multiple methods and build up one object.

### Outputting
Neio makes use of Context Types, which are not something that exists in other languages as of yet.
This means we had to create a custom translation for it.
The way we choose to translate it, is by breaking up the method chains created in the Text mode of a Neio document at every method call.
A variable is then assigned to the output of this method call.

// TODO: make clearer
To know what to call our method on, `ContextType`s were implemented as an extension of `RegularJavaType`s in Jnome.
A `RegularJavaType` is what we know as a Java class.
This `ContextType` adds a virtual inheritance relation between itself and the actual type of the method, and 
one between itself and the ContextType of this method.
The latter ContextType represents the Context at that point as we saw in {ctxTypes.ref()}.

When a lookup reaches a `ContextType` and asks us what our inherited members are (the members you normally receive from super classes), 
we return the members of all our inheritance relations. We only have two inheritance relations, the actual type and 
the ContextType. If what we are looking for was somewhere we could see, we will now have returned it and we are able to make use of it.
Lookups are provided by Chameleon and explaining how exactly they work is out of the scope of this Thesis.

We also hold a Stack of all the variables that have already been declared. When a lookup for a method, described above, succeeds, 
we check what type is returned by this method and look for the first variable in our stack of that type, popping everything on the way there.
We then know what to call our method on.

Lastly, we also have to translate `this`. The translation is analogue to the previous step, where we searched what to call the method on.
To have a starting point, we just replace `this` with the last defined variable and let the `ContextType`s do their job.
A translation for the very first example we looked at in this document is shown below.
{
    LstInputListing ctxExample = new LstInputListing('''../../examples/0.8/input/testInput/testInput/testInput.no''');
    return ctxExample;
}
{{
    ctxExample.leftOf(new LstListing('''
new Document()
    .newline()
    .newline()
    .#("Chapter 1")
    .newline()
    .text("This is some text in the first Paragraph");
    '''))
}}
{
    new LstInputListing('''testInput/testInput.java''')
}

Note that the middle end has created three functions. The first one is the main function, it allows the document to be executed as a whole.
It initialises the document class and then calls `createDocument` which actually creates an object model that will represent the document.
Finally `finishDocument` will compile the document to TeX and create a PDF of of it.

The reason we split up this process is so that we can call the creation of the document separately.
This allows us to include a document into another document by just calling the `createDocument` method with an appropriate argument.

The middle end also imported every namespace in the Neio library as well as the `java.util` namespace as it is possible that those will be needed.
The name of the Java class that is generated is the same as the name of the Neio document.

It is important to note that we only split up the methods chains created in Text mode.
The code written in code mode is kept as is, only occurrences of `this` are replaced.

### Reflection
In {nsCode.ref()} we touched on `addClassMapping` and said that the class mapping was comparable to a factory.
This is true and the need for it appeared when we wanted to create drop in replacements for objects that are created in Neio Text mode.
For example, if we want to use a special kind of `Chapter` in the `Document` document class, we would have to create a new document class that 
overrides the `\#` method, we also have to override the nested `\#` method in `Chapter` because otherwise only the first `Chapter` would be 
an instance of the special `Chapter`.

This is a problem that is normally solved by using factories.
When you know your object will create instances of other objects, in our example a `Document` creates `Chapter`s, 
that might be changed with more specialized forms of that object, you create a factory.
This factory however would have to be generic enough to be able to be used almost anywhere.
Even if we are able to do this, the writer of the specialized object would still have to create a new factory.
Factories usually are also very similar to each other, yet the code can not be reused.

For this reason we chose to swap out new calls with calls that use reflection to initialize the object.
This is a process that is executed in the middle end of the compiler.
Only the new calls of objects extending `Content` have been replaced as those should be the only thing a user wants to replace.
Every new call gets replaced by the `getInstance` call in the `Content` class.
The code needed to understand this process, as well as an example call is given below.
{
    Ranges reflectionRanges = new Ranges().add(17, 18).add(336, 398);
    new LstInputListing(reflectionRanges, '''../../examples/0.8/lib/neio/lang/Content.no''');
}
{
    new LstListing('''Chapter chapter = getInstance(Chapter.class, new Class[]{Text.class, Integer.class}, new Object[]{title, 1});''');
}

If you already understood the code from the comments, this paragraph can be skipped.
Every instance of content has a mapping from `Class` to `Class`, by default this mapping is empty.
When we want to use a specialized form of an object we call `addClassMapping`, as we did in {nsCode.ref()}.
Take the following example.
{
    new LstListing('''
[Document]
# Chapter 1
{
    nearestAncestor(Document.class).addClassMapping(Enumerate.class, FibEnumerate.class);
}
    ''')
}

We added a mapping from `Enumerate.class` to `FibEnumerate.class` in the root `Document`.
When we now call `getInstance(Enumerate.class, ...)`, this will be called on `Chapter`, not on `Document`.
But fear not, class mappings are looked up recursively. In the `getInstance` method we first check if we have 
a mapping for the class we are trying to instantiate. If we do the value of the mapping is used, if not we recursively 
check the mappings of our parents. If no mapping has been found after this, we just instantiate the class that has been given 
as argument to `getInstance`.

### Escaping
A Neio document is parsed and converted a number of times. First, it is parsed by the Neio compiler, then 
it is transformed into Java code that is then converted into {lat} code (in most cases).
This means that we have to handle escaping of characters in three different languages. Escaping in Neio is easy, 
just add a `\\` before the character you want to escape and it is escaped. Of course `\\\[ntr\]` hold on to their 
special meaning. However `\\\[bfu\]` have not been included in Neio as they are not yet needed. In the future it might 
prove useful to include these special characters to.

Moving on, we can not just translate these characters straight to Java as we have no special meaning for `\\\[bfu\]`.
For this reason the middle end transforms every backslash into two backslashes, and transforms a double backslash (used to denote an 
escaped single backslash in Neio) to four backslashes in Java as this is how you represent an escaped backslash in a Java String.
We then do some further translation in the Text class to assure that we are able to create valid latex.
{lat} only has ten special characters thus replacing is quite easy. The code to do the replacing is shown below.
{
    new LstInputListing(170, 191, '''../../examples/0.8/lib/neio/lang/Text.no''')
}

## Resource usage and creation
{Chapter rsc = (Chapter) parent()}
//TODO: don't forget this

## Limitations
Whilst development of the compiler a few limitations were discovered, they are discussed in this section.

### Windows
In {rsc.ref()} we saw that command line commands are sometimes executed. Executing commands using the Java Process class, however came with some not immediately visible issues.
When developing on Linux, executing shell commands from Java worked perfectly fine and gave no problems whatsoever.
However, on Windows some of the processes would hang, some would always hang, some would hang only once in a while.
The reason for this is that Windows offers only a limited buffer size for the input and output streams of a process, the program deadlocks if the input is not written or read.
After closer inspection of the Javadoc {cite('''javaprocess''')} this became apparent but since the API for the Process class is so simple, it was a surprise nevertheless.
The fact that we have to worry about different platforms on a cross-platform language as Java is also something that is not too common.

### Back end
About every back end has some limitations on how we can translate our Neio document. This is because Neio can use symbols as methods.
In Java, methods can only contain letters, numbers, \$ or \_. This means we have to translate the symbol function to valid Java identifiers.
The way we do this is very straightforward.
We use the following mapping and just replace any occurrence of a key in a method or method invocation with the value.
{
    new LstListing('''
"#" -> "hash"
"*" -> "star"
"=" -> "equalSign"
"^" -> "caret"
"-" -> "dash"
"_" -> "underscore"
"`" -> "backquote"
"$" -> "dollar"
"|" -> "pipe"
    ''')
}

With other back ends we would do the same, some languages allow you to overwrite operators but doing this might 
lead to unexpected side effects, thus just translating it this way seemed like the safest way to go.

# Future work
{Chapter fut = (Chapter) parent()}
As mentioned before in {considerations.ref()} there are still a few things that could be done in the future.
There are however a lot more things that could be done and we will discuss them in the rest of this chapter.

## Automatisation
#### Automatic StringBuilder
Since we are constantly translating to TeX and other formats, we use `StringBuilder` very often.
An example is almost every `toTex` method, we show the one defined in `Content` as an example.
{
    new LstInputListing(413, 427, '''../../examples/0.8/lib/neio/lang/Content.no''')
}

In fact we use it so many that in the future it might be better to just replace `String`s by `StringBuilder`s at all times.
This would make it easier for people to write packages. The performance gain, or loss of this would have to be investigated though.

#### Automatic return of the object itself
{Chapter autoRet = (Chapter) parent()}
Another pattern that is often encountered is that we often return the same object even when we have not changed it.
This is to be able to make use of fluent interfaces, as said before. An example from the `InlineEq` class is shown below.
{
    new LstInputListing(17, 27, '''../../examples/0.8/lib/neio/stdlib/math/InlineEq.no''')
}

We actually already have a solution for this, constructors.
Constructors do not tell us in their signature what they are going to return, but we do know what they are going to return.
No explicit return is needed either. Implementing this for other methods would allow us to lower the amount of boilerplate code that has to be written.

#### Automatic Text conversion
The final automation is needed to counter what we saw with the math library. There we had to open an inline 
code block just to open Text mode because that creates a `Text`. A way to prevent this would be to automatically convert `Content`, or maybe even `Object` 
in a generic way. In Java this is done through the `toString` method while in python the `repr` and `str` methods are used for this.
However if we were to implement it as naively as this, we would lose any kind of static typing when a Text is expected as an argument.
This does not seem like a good thing, especially when you consider that not every object might have a real textual representation.
This means that automatically transforming an object to text might in a lot of cases not even create a sensible result.

A better way might be to define an interface, `Representable`, that has a `repr` method. Any class that implements this class, and the native types such as String and Integer, 
could than be transformed into a Text using this `repr` method.

## Moving content
When we assign content to a variable, and apply small changes to it later on, it is possible that the content moves or that both the original and the new content are changed.
This is because the language does not enforce every placed content to be static and in turn this is the responsibility of the library developer and the user of those libraries.
We showed that we had to make sure that we cloned our objects when making changes to them before in {rbtChap.ref()} and {lily.ref()}.
It would be a very nice feature if Neio could enforce this behaviour by itself and take care of the implementation of clone by itself.
A way that this might be implemented is by copying objects that are going to be changed through reflection.
// TODO: is this correct?

## Use
## Packages
#### Package support
No package system was provided in this thesis, but in the future however it would be beneficial to do so.
It would allow users without a lot of technical expertise to import new functionality easily.
The way packaging is handled right now is straight through {lat} packages and Java packages.
We allow you to add {lat} packages through the `addPackage` method in `Document` and we allow you to import Java classes 
through the regular `import namespace` statements. To actually include a Neio library in the document, right now the source code for it 
has to be put into a folder, next to the rest of the standard Neio library. In the future we should be able to download (manually or automatically) packaged libraries 
and have them be stored somewhere else.

#### Implementation of packages
As we said before, non of the document classes or libraries that were created in this thesis are complete, and we also did not create that many of them, in comparison to what Java and {lat} offer that is.
In the future a lot of work should be put into writing complete libraries and porting libraries from other available languages such as {lat}.
This can however be done by the community for a big part, as is what happens for Java and {lat}.

## Compiler improvement
#### Efficiency
The compiler is fast enough for small documents but for a large document like this thesis, the compile time starts to ramp up.
The thesis takes about 30 seconds to a minute to compile, depending on the compute power of your computer.
This is on top of the `latexmk` that has to run afterwards and that also takes quite a while.
However no attention was paid to the efficiency of the compiler in this thesis, as thus it is likely that there are a lot of 
optimizations that can be performed.

#### Other front- and back ends
Another compiler improvement that could be created in the future, is that we could create different front and back ends.
We do not have to output to Java, if someone were to write a back end for python for example, we could make use of that back end.
The same thing is possible for the front end. The syntax of Neio documents and class files could be changed, as long as the fundamental 
design decisions of the language are kept the same, such as `ContextType`s and nested methods, another syntax could be designed. As long 
as a front end is developed that can parse a Neio document with a different syntax that can still parse the document into the same AST as is 
used at this moment, it is possible to change the currently used syntax..

## Tool improvement
To effectively be able to use Neio, we need some improvements to the tools available right now.
Chameleon provides support for the Eclipse IDE and in the future this could be used to improve our tooling.
#### Syntax highlighting
One of the base requirements to be able to work with a language is syntax highlighting.
This is one of the features that Chameleon provides through its Eclipse integration.
However it was not made for a language such as Neio where we represent a document as a series of method chains.
At this moment the Eclipse integration treats the entire method chain as a whole instead of every method call separately.
This would cause problems as everything between codeblocks would be colored the same and we would not be able to have different 
colouring for special methods, such as the symbol methods.

It should however work out of the box for Code mode and the class files.

#### Auto completion
A second feature that Chameleon offers and that is very useful when writing in a certain language, is auto completion.
This should again work well in Code mode and class files, however it would be a bit harder in Text mode.
This is because it would have to know when to auto complete and when it should just let us write.
It might be best to hide the auto complete behind a hotkey while in Text mode.
This still allows the user to get a list of methods he could use at a certain time, but would remove the annoyance of having a pop-up 
for auto completion come up at every word that is written.

#### IDE with preview
The last thing that would be a very nice to have for a markup language like this, would be an IDE that previews the document.
This is not something that is supported by Chameleon and would thus require quite a bit more work.
The compiler in its current state is also not ready for this, as said before it gets quite slow on large documents.
As it would have to be constantly running in the background, it would use a lot of energy (which is problematic for laptops) and would be too slow to actually produce results in time.

# Conclusion and reflection
#### Reflection
After having used the language for a year, written a Thesis in it and written a complete compiler for it, we found that it might have been better to just use 
almost pure java syntax as a front end. We changed a few things, such as adding syntactic sugar for new calls and calling packages, namespaces.
The reason for the latter was because in our eyes namespace was a more general time that better explained what this keyword did.

But by choosing different keywords, we ended up with name conflicts. At some point in development we wanted to make use of a class in a package called `namespace`.
Of course this did not work out well as the parser did not know how to parse this. By changing the syntax as much as we did, it also became impossible to run Javadoc 
on our class files without making major changes to it.

Disallowing a substantial part of Java (anonymous classes, shorthand operators such as `++`, `+=`, ...) and so on also hurts the 
adoption rate of the language as it is a bit harder to convert a Java file into a Neio file.

We think that it would have been better to have just used pure Java syntax and add the `nested` and `surround` modifiers to it, as well as allowing for symbols in the method names.
In the future we might then also add the proposition made in {autoRet.ref()}.

#### Conclusion
In the end we think we showed that is possible to create a healthy mix between user friendlyness and a powerful programming model.
We showed that the language can be as easy to read, write and learn as {md}.
While it can also be as powerful and diverse as {lat} whilst remaining quite legible.
A lot of work can still be done, and should still be done to commercially use Neio, as shown in {fut.ref()}, but we think that good basis has been provided.
The completion of this book should be enough proof of this.

// TODO: does this sound arrogant? I sure hope not
