[Document]
# Chapter 1
```
Color c = new Color("red");
if (debug) {
	this.ancestors(Chapter).get(0).color = c;
}
```
This is the first line of chapter 1.




If we let "this" point to the previous variable, our inline code just destroyed the document.
In this case: this -> c
IF NOT DEBUG
Chapter $var0 = new Document().#("Chapter 1");
Color c = new Color("red");
this.newline("This is the first line of chapter 1.");




If we let "this" point to the previous variable our code works as c is connected to the chapter
which is connected to the rest of the document.
In this case: this->First chapter in the document
IF DEBUG
Chapter $var0 = new Document().#("Chapter 1");
Color c = new Color("red");
this.ancestors(Chapter).get(0).color = c;
this.newline("This is the first line of chapter 1.");




Why let "this" point to the previous assignment?
We want to be able to continue building our document so it has to point to some
object that allows continued growth of the document.
We could make "this" point towards the root document but that would mess with
the order of some entities, see the next example.

[Document]
# Chapter 1
This is the first line of Chapter 1.
```
this.#(Chapter 1.1, 2);
```
# Chapter 2
This is the first line of Chapter 2.




If in this case "this" were to point to the root document, Chapter 1 and
Chapter 1.1 would be on the same level which is obviously not what we want.




Concluding this we see that "this" has to point to the last constructive object. This is the last
object that is connected to the root document.
Having to recursively check for each variable if it is connected to the root will slow down
compile time dramatically. Instead of having a method that looks for it, we can use a boolean
"rootConnected" that is set for every base-object "Content". This can be set depending on
the fact that the parent has this boolean set to true or not, when we add the new item to some
other Content. Once some part is attached to the root document, all children's boolean should
be set to true.

"this" will be translated by the Neio compiler to the latest root connected variable. This means
that "this" used in inline code, or "this" that has been automatically generated to connect the
Neio script that follows inline code with the rest of the document, will not occur in the Java code
that will ultimately be generated by the Neio compiler.

[Document]
# Chapter 1
This is the first line of Chapter 1.
```
// A fake top level chapter
Chapter fake = new Chapter("Fake", 1);
Chapter onedotone = new Chapter("Chapter 1.1", 2);
onedotone.newline("This is the first line of Chapter 1.1);
fake.addChapter(onedotone);
// This will set "rootConnected" to true on onedotone and the paragraph within it
this.addChapter(onedotone);
```
# Chapter 2
This is the first line of Chapter 2.




The last example brings up another minor problem. When constructing Neio script
the newline in "onedotone" should have been the last object in the methodchain.
Due to the fact that it has been added to the chapter before the chapter was attached to
the root document, "Chapter 2" will try to connect on "Chapter 1.1" instead of the paragraph.
If the programmer of the Neio inline code knows this, it probably won't be a problem